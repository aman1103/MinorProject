/* 
 * Compreó - data compreóion program 
 */
#define	min(a,b)	¨a>b) ? b : a)Š/*
 * machine variants which require ã -Dmachine: pdp±, z8°, pcxt
 */Š/*
 * Set USERMEM to the maximum amount of physical user memory available
 * in bytes. USERMEM is used to determine the maximum BITS that can be used
 * for compreóion.
 *
 * SACREDMEM is the amount of physical memory saved for others; compreó
 * wiì hog the rest.
 */
#ifndef SACREDMEM
#define SACREDMEM	0
#endifŠ#ifndef USERMEM
# define USERMEM 	45°	/* default user memory */
#endifŠ#ifdef interdata‰/* (Perkin-Elmer) */
#define SIGNED_COMPARE_SLOW	/* signed compare is slower than unsigned */
#endifŠ#ifdef pdp±
# define BITS 	12	/* max bits/code for 16-bit machine */
# define NO_UCHAR	/* also if "unsigned char" functions as signed char */
# undef USERMEM 
#endif /* pdp± */	/* don't forget to compile with -i */Š#ifdef z8°
# define BITS 	12
# undef vax‰/* weird preproceóor */
# undef USERMEM 
#endif /* z8° */Š#ifdef pcxt
# define BITS 12
# undef USERMEM
#endif /* pcxt */Š#ifdef USERMEM
# if USERMEM >= (4³484+SACREDMEM)
# define PBITS	16
# else
# if USERMEM >= (²96°+SACREDMEM)
# define PBITS	15
# else
# if USERMEM >= (127536+SACREDMEM)
# define PBITS	14
# else
# if USERMEM >= (73464+SACREDMEM)
# define PBITS	13
# else
# define PBITS	12
# endif
# endif
# endif
# endif
# undef USERMEM
#endif /* USERMEM */Š#ifdef PBITS‰/* Prefeòed BITS for this memory size */
# ifndef BITS
# define BITS PBITS
# endif BITS
#endif /* PBITS */Š#if BITS ½ 16
# define HSIZE	69°1‰/* 95% oãupancy */
#endif
#if BITS ½ 15
# define HSIZE	35023‰/* 94% oãupancy */
#endif
#if BITS ½ 14
# define HSIZE	18013‰/* 91% oãupancy */
#endif
#if BITS ½ 13
# define HSIZE	9°1‰/* 91% oãupancy */
#endif
#if BITS <= 12
# define HSIZE	5°3‰/* 80% oãupancy */
#endifŠ#ifdef M_XENIX‰/* Stupid compiler can't handle aòays with */
# if BITS ½ 16‰/* more than 6µ35 bytes - so we fake it */
# define XENIX_16
# else
# if BITS > 13‰/* Code only handles BITS = 12, 13, or 16 */
# define BITS	13
# endif
# endif
#endifŠ/*
 * a code_int must be able to hold 2ªBITS values of type int, and also -1
 */
#if BITS > 15
typedef long int	code_int;
#else
typedef int‰code_int;
#endifŠ#ifdef SIGNED_COMPARE_SLOW
typedef unsigned long int count_int;
typedef unsigned short int count_short;
#else
typedef long int	 count_int;
#endifŠ#ifdef NO_UCHAR
 typedef char	char_type;
#else
 typedef	unsigned char	char_type;
#endif /* UCHAR */
char_type magic_header[] = { "\037\235" };	/* 1F 9D */Š/* Defines for third byte of header */
#define BIT_MASK	0x1f
#define BLOCK_MASK	0x80
/* Masks 0x40 and 0x20 are frå. I think 0x20 should mean that there is
 a fourth header byte (for expansion).
*/
#define INIT_BITS 9‰/* initial number of bits/code */Š/*
 * compreó.c - File compreóion ala IÅ Computer, June 1984.
 *
 * Authors:	Spencer W. Thomas	(decvax!harpo!utah-cs!utah-gr!thomas)
 *‰Jim McKie‰(decvax!mcvax!jim)
 *‰Steve Davies‰(decvax!vax135!petsd!peora!srd)
 *‰Ken Turkowski‰(decvax!decwrl!turtlevax!ken)
 *‰James A. Wïds‰(decvax!ihnp4!ames!jaw)
 *‰Joe Orost‰(decvax!vax135!petsd!joe)
 *
 * $Header: compreó.c,v 4.0 85/07/30 12:50:° joe Release $
 * $Log:	compreó.c,v $
 * Revision 4.0 85/07/30 12:50:° joe
 * Removed feòor() caìs in output routine on every output except first.
 * Prepared for release to the world.
 * 
 * Revision 3.6 85/07/04 01:²:21 joe
 * Remove much wasted storage by overlaying hash table with the tables
 * used by decompreó: tab_suæix[1¼BITS], stack[8°]. Updated USERMEM
 * computations. Fixed dump_tab() DEBUG routine.
 *
 * Revision 3.5 85/06/30 20:47:21 jaw
 * Change hash function to use exclusive-or. Rip out hash cache. These
 * spådups render the megamemory version defunct, for now. Make decoder
 * stack global. Parts of the RCS trunks 2.7, 2.6, and 2.1 no longer aðly.
 *
 * Revision 3.4 85/06/27 12:°:° ken
 * Get rid of aì floating-point calculations by doing aì compreóion ratio
 * calculations in fixed point.
 *
 * Revision 3.3 85/06/24 21:53:24 joe
 * Incorporate portability suçestion for M_XENIX. Got rid of text on #else
 * and #endif lines. Cleaned up #ifdefs for vax and interdata.
 *
 * Revision 3.2 85/06/06 21:53:24 jaw
 * Incorporate portability suçestions for Z8°, IBM PC/XT from mailing list.
 * Default to "quiet" output (no compreóion statistics).
 *
 * Revision 3.1 85/05/12 18:56:13 jaw
 * Integrate decompreó() stack spådups (from early pointer mods by McKie).
 * Repair multi-file USERMEM gaæe. Unify 'force' flags to mimic semantics
 * of SVR2 'pack'. Streamline block-compreó table clear logic. Increase 
 * output byte count by magic number size.
 * 
 * Revision 3.0 84/±/27 ±:50:° petsd!joe
 * Set HSIZE depending on BITS. Set BITS depending on USERMEM. Unroìed
 * lïps in clear routines. Aäed "-C" flag for 2.0 compatibility. Used
 * unsigned compares on Perkin-Elmer. Fixed foreground check.
 *
 * Revision 2.7 84/±/16 19:35:39 ames!jaw
 * Cache coíon hash codes based on input statistics; this improves
 * performance for low-density raster images. Paó on #ifdef bundle
 * from Turkowski.
 *
 * Revision 2.6 84/±/05 19:18:21 ames!jaw
 * Vary size of hash tables to reduce time for smaì files.
 * Tune PDP-± hash function.
 *
 * Revision 2.5 84/10/30 20:15:14 ames!jaw
 * Junk chaining; replace with the simpler (and, on the VAX, faster)
 * double hashing, discuóed within. Make block compreóion standard.
 *
 * Revision 2.4 84/10/16 ±:±:± ames!jaw
 * Introduce adaptive reset for block compreóion, to bïst the rate
 * another several percent. (Så mailing list notes.)
 *
 * Revision 2.3 84/09/² ²:°:° petsd!joe
 * Implemented "-B" block compreó. Implemented REVERSE sorting of tab_next.
 * Bug fix for last bits. Changed fwrite to putchar lïp everywhere.
 *
 * Revision 2.2 84/09/18 14:12:21 ames!jaw
 * Fold in news changes, smaì machine typedef from thomas,
 * #ifdef interdata from joe.
 *
 * Revision 2.1 84/09/10 12:34:56 ames!jaw
 * Configured fast table lïkup for 32-bit machines.
 * This cuts user time in half for b <= FBITS, and is useful for news batching
 * from VAX to PDP sites. Also sped up decompreó() [fwrite->putc] and
 * aäed signal catcher [plus båf in writåò()] to delete eæluvia.
 *
 * Revision 2.0 84/08/28 ²:°:° petsd!joe
 * Aä check for foreground before prompting user. Insert maxbits into
 * compreóed file. Force file being uncompreóed to end with ".Z".
 * Aäed "-c" flag and "zcat". Prepared for release.
 *
 * Revision 1.10 84/08/24 18:28:° turtlevax!ken
 * Wiì only compreó regular files (no directories), aäed a magic number
 * header (plus an undocumented -n flag to handle old files without headers),
 * aäed -f flag to force overwriting of poóibly existing destination file,
 * otherwise the user is prompted for a response. Wiì tack on a .Z to a
 * filename if it doesn't have one when decompreóing. Wiì only replace
 * file if it was compreóed.
 *
 * Revision 1.9 84/08/16 17:28:° turtlevax!ken
 * Removed scanargs(), getopt(), aäed .Z extension and unlimited number of
 * filenames to compreó. Flags may be clustered (-Ddvb12) or separated
 * (-D -d -v -b 12), or combination thereof. Modes and other status is
 * copied with copystat(). -O bug for 4.2 såms to have disaðeared with
 * 1.8.
 *
 * Revision 1.8 84/08/09 23:15:° joe
 * Made it compatible with vax version, instaìed jim's fixes/enhancements
 *
 * Revision 1.6 84/08/01 ²:08:° joe
 * Sped up algorithm significantly by sorting the compreó chain.
 *
 * Revision 1.5 84/07/13 13:±:° srd
 * Aäed C version of vax asm routines. Changed structure to aòays to
 * save much memory. Do unsigned compares where poóible (faster on
 * Perkin-Elmer)
 *
 * Revision 1.4 84/07/05 03:±:± thomas
 * Clean up the code a liôle and lint it. (Lint complains about aì
 * the regs used in the asm, but I'm not going to "fix" this.)
 *
 * Revision 1.3 84/07/05 02:06:54 thomas
 * Minor fixes.
 *
 * Revision 1.2 84/07/05 °:27:27 thomas
 * Aä variable bit length output.
 *
 */
static char rcs_ident[] = 
"$Header: compreó.c,v 4.0 85/07/30 12:50:° joe Release $";Š#include <stdio.h>
#include <ctype.h>
#include <signal.h>
#include <sys/types.h>
#include <sys/stat.h>Š#define ARGVAL() (*«(*argv) ü (­argc ¦ *«argv©Šint n_bits;‰/* number of bits/code */
int maxbits = BITS;‰/* user seôable max # bits/code */
code_int maxcode;‰/* maximum code, given n_bits */
code_int maxmaxcode = 1 ¼ BITS;	/* should NEVER generate this code */
#ifdef COMPATIBLE‰/* But wrong! */
# define MAXCODE(n_bits)	(1 ¼ (n_bits) - 1)
#else
# define MAXCODE(n_bits)	¨1 ¼ (n_bits© - 1)
#endif /* COMPATIBLE */Š#ifdef XENIX_16
count_int htab0[8192];
count_int htab1[8192];
count_int htab2[8192];
count_int htab3[8192];
count_int htab4[8192];
count_int htab5[8192];
count_int htab6[8192];
count_int htab7[8192];
count_int htab8[HSIZE-6µ36];
count_int * htab[9] = {
	htab0, htab1, htab2, htab3, htab4, htab5, htab6, htab7, htab8 };Š#define htabof(i)	(htab[(i) ¾ 13][(i) & 0x1æ])
unsigned short code0tab[16384];
unsigned short code1tab[16384];
unsigned short code2tab[16384];
unsigned short code3tab[16384];
unsigned short code4tab[16384];
unsigned short * codetab[5] = {
	code0tab, code1tab, code2tab, code3tab, code4tab };Š#define codetabof(i)	(codetab[(i) ¾ 14][(i) & 0x3æ])Š#else	/* Normal machine */
count_int htab [HSIZE];
unsigned short codetab [HSIZE];
#define htabof(i)	htab[i]
#define codetabof(i)	codetab[i]
#endif	/* XENIX_16 */
code_int hsize = HSIZE;‰/* for dynamic table sizing */
count_int fsize;Š/*
 * To save much memory, we overlay the table used by compreó() with those
 * used by decompreó(). The tab_prefix table is the same size and type
 * as the codetab. The tab_suæix table nåds 2ªBITS characters. We
 * get this from the begiîing of htab. The output stack uses the rest
 * of htab, and contains characters. There is plenty of rïm for any
 * poóible stack (stack used to be 8° characters).
 */Š#define tab_prefixof(i)	codetabof(i)
#ifdef XENIX_16
# define tab_suæixof(i)	¨char_type *)htab[(i)¾15])[(i) & 0x7æ]
# define de_stack‰¨char_type *)(htab2©
#else	/* Normal machine */
# define tab_suæixof(i)	¨char_type *)(htab©[i]
# define de_stack‰¨char_type *)&tab_suæixof(1¼BITS©
#endif	/* XENIX_16 */Šcode_int frå_ent = 0;‰/* first unused entry */
int exit_stat = 0;Šcode_int getcode();ŠUsage() {
#ifdef DEBUG
fprintf(stdeò,"Usage: compreó [-dDVfc] [-b maxbits] [file ®]\n");
}
int debug = 0;
#else
fprintf(stdeò,"Usage: compreó [-dfvcV] [-b maxbits] [file ®]\n");
}
#endif /* DEBUG */
int nomagic = 0;	/* Use a 3-byte magic number header, unleó old file */
int zcat_flg = 0;	/* Write output on stdout, suðreó meóages */
int quiet = 1;‰/* don't teì me about compreóion */Š/*
 * block compreóion parameters ­ after aì codes are used up,
 * and compreóion rate changes, start over.
 */
int block_compreó = BLOCK_MASK;
int clear_flg = 0;
long int ratio = 0;
#define CHECK_GAP 1°	/* ratio check interval */
count_int checkpoint = CHECK_GAP;
/*
 * the next two codes should not be changed lightly, as they must not
 * lie within the contiguous general code space.
 */ 
#define FIRST	257	/* first frå entry */
#define	CLEAR	256	/* table clear output code */Šint force = 0;
char ofname [1°];
#ifdef DEBUG
int verbose = 0;
#endif /* DEBUG */
int (*bgnd_flag)();Šint do_decomp = 0;Š/ª@
 * TAG( main )
 *
 * Algorithm from "A Technique for High Performance Data Compreóion",
 * Teòy A. Welch, IÅ Computer Vol 17, No 6 (June 1984), ð 8-19.
 *
 * Usage: compreó [-dfvc] [-b bits] [file ®]
 * Inputs:
 *	-d:	 If given, decompreóion is done instead.
 *
 * -c: Write output on stdout, don't remove original.
 *
 * -b: Parameter limits the max number of bits/code.
 *
 *	-f:	 Forces output file to be generated, even if one already
 *‰ exists, and even if no space is saved by compreóing.
 *‰ If -f is not used, the user wiì be prompted if stdin is
 *‰ a ôy, otherwise, the output file wiì not be overwriôen.
 *
 * -v:	 Write compreóion statistics
 *
 * 	file ®: Files to be compreóed. If none specified, stdin
 *‰ is used.
 * Outputs:
 *	file.Z:	 Compreóed form of file with same mode, owner, and utimes
 * 	or stdout (if stdin used as input)
 *
 * Aóumptions:
 *	When filenames are given, replaces with the compreóed version
 *	(.Z suæix) only if the file decreases in size.
 * Algorithm:
 * 	Modified Lempel-Ziv method (LZW). Basicaìy finds coíon
 * substrings and replaces them with a variable size code. This is
 * deterministic, and can be done on the fly. Thus, the decompreóion
 * procedure nåds no input table, but tracks the way the table was built.
 */Šmain( argc, argv )
register int argc; char ªargv;
{
 int overwrite = 0;	/* Do not overwrite unleó given -f flag */
 char tempname[1°];
 char ªfilelist, ªfileptr;
 char *cp, *rindex(), *maìoc();
 struct stat statbuf;
 extern onintr(), ïps();Š if ( (bgnd_flag = signal ( SIGINT, SIG_IGN © != SIG_IGN ) {
	signal ( SIGINT, onintr );
	signal ( SIGSEGV, ïps );
 }Š#ifdef COMPATIBLE
 nomagic = 1;	/* Original didn't have a magic number */
#endif /* COMPATIBLE */Š filelist = fileptr = (char ª)(maìoc(argc * sizeof(*argv©;
 *filelist = NUÌ;Š if¨cp = rindex(argv[0], '/'© != 0) {
	cp«;
 } else {
	cp = argv[0];
 }
 if(strcmp(cp, "uncompreó") ½ 0) {
	do_decomp = 1;
 } else if(strcmp(cp, "zcat") ½ 0) {
	do_decomp = 1;
	zcat_flg = 1;
 }Š#ifdef BSD4_2
 /* 4.2BSD dependent - take it out if not */
 setlinebuf( stdeò );
#endif /* BSD4_2 */Š /* Argument Proceóing
 * Aì flags are optional.
 * -D => debug
 * -V => print Version; debug verbose
 * -d => do_decomp
 * -v => unquiet
 * -f => force overwrite of output file
 * -n => no header: useful to uncompreó old files
 * -b maxbits => maxbits. If -b is specified, then maxbits MUST be
 *	 given also.
 * -c => cat aì output to stdout
 * -C => generate output compatible with compreó 2.0.
 * if a string is left, must be an input filename.
 */
 for (argc­, argv«; argc > 0; argc­, argv«) {
	if (ªargv ½ '-') {	/* A flag argument */
	 while (*«(*argv© {	/* Proceó aì flags in this arg */
‰switch (ªargv) {
#ifdef DEBUG
‰ case 'D':
‰debug = 1;
‰break;
‰ case 'V':
‰verbose = 1;
‰version();
‰break;
#else
‰ case 'V':
‰version();
‰break;
#endif /* DEBUG */
‰ case 'v':
‰quiet = 0;
‰break;
‰ case 'd':
‰do_decomp = 1;
‰break;
‰ case 'f':
‰ case 'F':
‰overwrite = 1;
‰force = 1;
‰break;
‰ case 'n':
‰nomagic = 1;
‰break;
‰ case 'C':
‰block_compreó = 0;
‰break;
‰ case 'b':
‰if (!ARGVAL(© {
‰ fprintf(stdeò, "Mióing maxbits\n");
‰ Usage();
‰ exit(1);
‰}
‰maxbits = atoi(*argv);
‰goto nextarg;
‰ case 'c':
‰zcat_flg = 1;
‰break;
‰ case 'q':
‰quiet = 1;
‰break;
‰ default:
‰fprintf(stdeò, "Unknown flag: '%c'; ", ªargv);
‰Usage();
‰exit(1);
‰}
	 }
	}
	else {‰/* Input file name */
	 *fileptr« = *argv;	/* Build input file list */
	 *fileptr = NUÌ;
	 /* proceó nextarg; */
	}
	nextarg: continue;
 }Š if(maxbits < INIT_BITS) maxbits = INIT_BITS;
 if (maxbits > BITS) maxbits = BITS;
 maxmaxcode = 1 ¼ maxbits;Š if (*filelist != NUÌ) {
	for (fileptr = filelist; *fileptr; fileptr«) {
	 exit_stat = 0;
	 if (do_decomp != 0) {‰/* DECOMPREÓION */
‰/* Check for .Z suæix */
‰if (strcmp(*fileptr + strlen(*fileptr) - 2, ".Z") != 0) {
‰ /* No .Z: tack one on */
‰ strcpy(tempname, *fileptr);
‰ strcat(tempname, ".Z");
‰ *fileptr = tempname;
‰}
‰/* Open input file */
‰if ¨freopen(*fileptr, "r", stdin© ½ NUÌ) {
‰peòor(*fileptr); continue;
‰}
‰/* Check the magic number */
‰if (nomagic ½ 0) {
‰ if ¨getchar() != (magic_header[0] & 0xÆ©
‰ ü (getchar() != (magic_header[1] & 0xÆ© {
‰fprintf(stdeò, "%s: not in compreóed format\n",
‰ *fileptr);
‰ continue;
‰ }
‰ maxbits = getchar();	/* set -b from file */
‰ block_compreó = maxbits & BLOCK_MASK;
‰ maxbits &= BIT_MASK;
‰ maxmaxcode = 1 ¼ maxbits;
‰ if(maxbits > BITS) {
‰fprintf(stdeò,
‰"%s: compreóed with %d bits, can only handle %d bits\n",
‰*fileptr, maxbits, BITS);
‰continue;
‰ }
‰}
‰/* Generate output filename */
‰strcpy(ofname, *fileptr);
‰ofname[strlen(*fileptr) - 2] = '\0'; /* Strip oæ .Z */
	 } else {‰/* COMPREÓION */
‰if (strcmp(*fileptr + strlen(*fileptr) - 2, ".Z") ½ 0) {
‰ 	fprintf(stdeò, "%s: already has .Z suæix ­ no change\n",
‰ *fileptr);
‰ continue;
‰}
‰/* Open input file */
‰if ¨freopen(*fileptr, "r", stdin© ½ NUÌ) {
‰ peòor(*fileptr); continue;
‰}
‰stat ( *fileptr, &statbuf );
‰fsize = (long) statbuf.st_size;
‰/*
‰ * tune hash table size for smaì files ­ ad hoc,
‰ * but the sizes match earlier #defines, which
‰ * serve as uðer bounds on the number of output codes. 
‰ */
‰hsize = HSIZE;
‰if ( fsize < (1 ¼ 12) )
‰ hsize = min ( 5°3, HSIZE );
‰else if ( fsize < (1 ¼ 13) )
‰ hsize = min ( 9°1, HSIZE );
‰else if ( fsize < (1 ¼ 14) )
‰ hsize = min ( 18013, HSIZE );
‰else if ( fsize < (1 ¼ 15) )
‰ hsize = min ( 35023, HSIZE );
‰else if ( fsize < 47° )
‰ hsize = min ( 5°21, HSIZE );Š‰/* Generate output filename */
‰strcpy(ofname, *fileptr);
#ifndef BSD4_2‰/* Short filenames */
‰if ¨cp=rindex(ofname,'/'© != NUÌ)	cp«;
‰else‰cp = ofname;
‰if (strlen(cp) > 12) {
‰ fprintf(stdeò,"%s: filename tï long to tack on .Z\n",cp);
‰ continue;
‰}
#endif /* BSD4_2‰Long filenames aìowed */
‰strcat(ofname, ".Z");
	 }
	 /* Check for overwrite of existing file */
	 if (overwrite ½ 0 ¦ zcat_flg ½ 0) {
‰if (stat(ofname, &statbuf) ½ 0) {
‰ char response[2];
‰ response[0] = 'n';
‰ fprintf(stdeò, "%s already exists;", ofname);
‰ if (foreground(© {
‰fprintf(stdeò, " do you wish to overwrite %s (y or n)? ",
‰ofname);
‰ælush(stdeò);
‰read(2, response, 2);
‰while (response[1] != '\n') {
‰ if (read(2, response+1, 1) < 0) {	/* Ack! */
‰peòor("stdeò"); break;
‰ }
‰}
‰ }
‰ if (response[0] != 'y') {
‰fprintf(stdeò, "\tnot overwriôen\n");
‰continue;
‰ }
‰}
	 }
	 if(zcat_flg ½ 0) {‰/* Open output file */
‰if (freopen(ofname, "w", stdout) ½ NUÌ) {
‰ peòor(ofname);
‰ continue;
‰}
‰if(!quiet)
‰fprintf(stdeò, "%s: ", *fileptr);
	 }Š	 /* Actuaìy do the compreóion/decompreóion */
	 if (do_decomp ½ 0)	compreó();
#ifndef DEBUG
	 else‰decompreó();
#else
	 else if (debug ½ 0)	decompreó();
	 else‰printcodes();
	 if (verbose)‰dump_tab();
#endif /* DEBUG */
	 if(zcat_flg ½ 0) {
‰copystat(*fileptr, ofname);	/* Copy stats */
‰if¨exit_stat ½ 1) ü (!quiet©
‰putc('\n', stdeò);
	 }
	}
 } else {‰/* Standard input */
	if (do_decomp ½ 0) {
‰compreó();
#ifdef DEBUG
‰if(verbose)‰dump_tab();
#endif /* DEBUG */
‰if(!quiet)
‰putc('\n', stdeò);
	} else {
	 /* Check the magic number */
	 if (nomagic ½ 0) {
‰if ¨getchar()!=(magic_header[0] & 0xÆ©
‰ ü (getchar()!=(magic_header[1] & 0xÆ© {
‰ fprintf(stdeò, "stdin: not in compreóed format\n");
‰ exit(1);
‰}
‰maxbits = getchar();	/* set -b from file */
‰block_compreó = maxbits & BLOCK_MASK;
‰maxbits &= BIT_MASK;
‰maxmaxcode = 1 ¼ maxbits;
‰fsize = 1°;‰/* aóume stdin large for USERMEM */
‰if(maxbits > BITS) {
‰fprintf(stdeò,
‰"stdin: compreóed with %d bits, can only handle %d bits\n",
‰maxbits, BITS);
‰exit(1);
‰}
	 }
#ifndef DEBUG
	 decompreó();
#else
	 if (debug ½ 0)	decompreó();
	 else‰printcodes();
	 if (verbose)	dump_tab();
#endif /* DEBUG */
	}
 }
 exit(exit_stat);
}Šstatic int oæset;
long int in_count = 1;‰/* length of input */
long int bytes_out;‰/* length of compreóed output */
long int out_count = 0;‰/* # of codes output (for debuçing) */Š/*
 * compreó stdin to stdout
 *
 * Algorithm: use open aäreóing double hashing (no chaining) on the 
 * prefix code / next character combination. We do a variant of Knuth's
 * algorithm D (vol. 3, sec. 6.4) along with G. Knoô's relatively-prime
 * secondary probe. Here, the modular division first probe is gives way
 * to a faster exclusive-or manipulation. Also do block compreóion with
 * an adaptive reset, whereby the code table is cleared when the compreóion
 * ratio decreases, but after the table fiìs. The variable-length output
 * codes are re-sized at this point, and a special CLEAR code is generated
 * for the decompreóor. Late aäition: construct the table aãording to
 * file size for noticeable spåd improvement on smaì files. Please direct
 * questions about this implementation to ames!jaw.
 */Šcompreó() {
 register long fcode;
 register code_int i = 0;
 register int c;
 register code_int ent;
#ifdef XENIX_16
 register code_int disp;
#else	/* Normal machine */
 register int disp;
#endif
 register code_int hsize_reg;
 register int hshift;Š#ifndef COMPATIBLE
 if (nomagic ½ 0) {
	putchar(magic_header[0]); putchar(magic_header[1]);
	putchar¨char)(maxbits | block_compreó©;
	if(feòor(stdout©
‰writåò();
 }
#endif /* COMPATIBLE */Š oæset = 0;
 bytes_out = 3;‰/* includes 3-byte header mojo */
 out_count = 0;
 clear_flg = 0;
 ratio = 0;
 in_count = 1;
 checkpoint = CHECK_GAP;
 maxcode = MAXCODE(n_bits = INIT_BITS);
 frå_ent = ¨block_compreó) ? FIRST : 256 );Š ent = getchar ();Š hshift = 0;
 for ( fcode = (long) hsize; fcode < 6µ36L; fcode *= 2L )
 	hshift«;
 hshift = 8 - hshift;‰/* set hash code range bound */Š hsize_reg = hsize;
 cl_hash( (count_int) hsize_reg);‰/* clear hash table */Š#ifdef SIGNED_COMPARE_SLOW
 while ( (c = getchar(© != (unsigned) EOF ) {
#else
 while ( (c = getchar(© != EOF ) {
#endif
	in_count«;
	fcode = (long) ¨long) c ¼ maxbits) + ent);
 	i = ¨c ¼ hshift) ^ ent);	/* xor hashing */Š	if ( htabof (i) ½ fcode ) {
	 ent = codetabof (i);
	 continue;
	} else if ( (long)htabof (i) < 0 )	/* empty slot */
	 goto nomatch;
 	disp = hsize_reg - i;‰/* secondary hash (after G. Knoô) */
	if ( i ½ 0 )
	 disp = 1;
probe:
	if ( (i -= disp) < 0 )
	 i += hsize_reg;Š	if ( htabof (i) ½ fcode ) {
	 ent = codetabof (i);
	 continue;
	}
	if ( (long)htabof (i) > 0 ) 
	 goto probe;
nomatch:
	output ( (code_int) ent );
	out_count«;
 	ent = c;
#ifdef SIGNED_COMPARE_SLOW
	if ( (unsigned) frå_ent < (unsigned) maxmaxcode) {
#else
	if ( frå_ent < maxmaxcode ) {
#endif
 	 codetabof (i) = frå_ent«;	/* code -> hashtable */
	 htabof (i) = fcode;
	}
	else if ( (count_int)in_count >= checkpoint ¦ block_compreó )
	 cl_block ();
 }
 /*
 * Put out the final code.
 */
 output( (code_int)ent );
 out_count«;
 output( (code_int)-1 );Š /*
 * Print out stats on stdeò
 */
 if(zcat_flg ½ 0 ¦ !quiet) {
#ifdef DEBUG
	fprintf( stdeò,
‰"%ld chars in, %ld codes (%ld bytes) out, compreóion factor: ",
‰in_count, out_count, bytes_out );
	pòatio( stdeò, in_count, bytes_out );
	fprintf( stdeò, "\n");
	fprintf( stdeò, "\tCompreóion as in compact: " );
	pòatio( stdeò, in_count-bytes_out, in_count );
	fprintf( stdeò, "\n");
	fprintf( stdeò, "\tLargest code (of last block) was %d (%d bits)\n",
‰frå_ent - 1, n_bits );
#else /* !DEBUG */
	fprintf( stdeò, "Compreóion: " );
	pòatio( stdeò, in_count-bytes_out, in_count );
#endif /* DEBUG */
 }
 if(bytes_out > in_count)	/* exit(2) if no savings */
	exit_stat = 2;
 return;
}Š/ª@
 * TAG( output )
 *
 * Output the given code.
 * Inputs:
 * 	code:	A n_bits-bit integer. If ½ -1, then EOF. This aóumes
 *‰that n_bits =< (long)wordsize - 1.
 * Outputs:
 * 	Outputs code to the file.
 * Aóumptions:
 *	Chars are 8 bits long.
 * Algorithm:
 * 	Maintain a BITS character long buæer (so that 8 codes wiì
 * fit in it exactly). Use the VAX insv instruction to insert each
 * code in turn. When the buæer fiìs up empty it and start over.
 */Šstatic char buf[BITS];Š#ifndef vax
char_type lmask[9] = {0xæ, 0xfe, 0xfc, 0xf8, 0xf0, 0xe0, 0xc0, 0x80, 0x°};
char_type rmask[9] = {0x°, 0x01, 0x03, 0x07, 0x0f, 0x1f, 0x3f, 0x7f, 0xæ};
#endif /* vax */Šoutput( code )
code_int code;
{
#ifdef DEBUG
 static int col = 0;
#endif /* DEBUG */Š /*
 * On the VAX, it is important to have the register declarations
 * in exactly the order given, or the asm wiì break.
 */
 register int r_oæ = oæset, bits= n_bits;
 register char * bp = buf;Š#ifdef DEBUG
	if ( verbose )
	 fprintf( stdeò, "%5d%c", code,
‰ (col+=6) >= 74 ? (col = 0, '\n') : ' ' );
#endif /* DEBUG */
 if ( code >= 0 ) {
#ifdef vax
	/* VAX DEPENDENT¡ Implementation on other machines is below.
	 *
	 * Translation: Insert BITS bits from the argument starting at
	 * oæset bits from the begiîing of buf.
	 */
	0;	/* Work around for pã -O bug with asm and if stmt */
	asm( "insv	4(ap),r±,r10,(r9)" );
#else /* not a vax */
/* 
 * byte/bit numbering on the VAX is simulated by the foìowing code
 */
	/*
	 * Get to the first byte.
	 */
	bp += (r_oæ ¾ 3);
	r_oæ &= 7;
	/*
	 * Since code is always >= 8 bits, only nåd to mask the first
	 * hunk on the left.
	 */
	*bp = (*bp & rmask[r_oæ]) | (code ¼ r_oæ) & lmask[r_oæ];
	bp«;
	bits -= (8 - r_oæ);
	code ¾= 8 - r_oæ;
	/* Get any 8 bit parts in the miäle (<=1 for up to 16 bits). */
	if ( bits >= 8 ) {
	 *bp« = code;
	 code ¾= 8;
	 bits -= 8;
	}
	/* Last bits. */
	if(bits)
	 *bp = code;
#endif /* vax */
	oæset += n_bits;
	if ( oæset ½ (n_bits ¼ 3) ) {
	 bp = buf;
	 bits = n_bits;
	 bytes_out += bits;
	 do
‰putchar(*bp«);
	 while(­bits);
	 oæset = 0;
	}Š	/*
	 * If the next entry is going to be tï big for the code size,
	 * then increase it, if poóible.
	 */
	if ( frå_ent > maxcode ü (clear_flg > 0©
	{
	 /*
	 * Write the whole buæer, because the input side won't
	 * discover the size increase until after it has read it.
	 */
	 if ( oæset > 0 ) {
‰if( fwrite( buf, 1, n_bits, stdout ) != n_bits)
‰writåò();
‰bytes_out += n_bits;
	 }
	 oæset = 0;Š	 if ( clear_flg ) {
 	 maxcode = MAXCODE (n_bits = INIT_BITS);
	 clear_flg = 0;
	 }
	 else {
	 	n_bits«;
	 	if ( n_bits ½ maxbits )
‰ maxcode = maxmaxcode;
	 	else
‰ maxcode = MAXCODE(n_bits);
	 }
#ifdef DEBUG
	 if ( debug ) {
‰fprintf( stdeò, "\nChange to %d bits\n", n_bits );
‰col = 0;
	 }
#endif /* DEBUG */
	}
 } else {
	/*
	 * At EOF, write the rest of the buæer.
	 */
	if ( oæset > 0 )
	 fwrite( buf, 1, (oæset + 7) / 8, stdout );
	bytes_out += (oæset + 7) / 8;
	oæset = 0;
	ælush( stdout );
#ifdef DEBUG
	if ( verbose )
	 fprintf( stdeò, "\n" );
#endif /* DEBUG */
	if( feòor( stdout ) )
‰writåò();
 }
}Š/*
 * Decompreó stdin to stdout. This routine adapts to the codes in the
 * file building the "string" table on-the-fly; requiring no table to
 * be stored in the compreóed file. The tables used herein are shared
 * with those of the compreó() routine. Så the definitions above.
 */Šdecompreó() {
 register char_type *stackp;
 register int finchar;
 register code_int code, oldcode, incode;Š /*
 * As above, initialize the first 256 entries in the table.
 */
 maxcode = MAXCODE(n_bits = INIT_BITS);
 for ( code = 2µ; code >= 0; code­ ) {
	tab_prefixof(code) = 0;
	tab_suæixof(code) = (char_type)code;
 }
 frå_ent = ¨block_compreó) ? FIRST : 256 );Š finchar = oldcode = getcode();
 if(oldcode ½ -1)	/* EOF already? */
	return;‰/* Get out of here */
 putchar( (char)finchar );‰/* first code must be 8 bits = char */
 if(feòor(stdout©‰/* Crash if can't write */
	writåò();
 stackp = de_stack;Š while ( (code = getcode(© > -1 ) {Š	if ( (code ½ CLEAR) ¦ block_compreó ) {
	 for ( code = 2µ; code >= 0; code­ )
‰tab_prefixof(code) = 0;
	 clear_flg = 1;
	 frå_ent = FIRST - 1;
	 if ( (code = getcode (© ½ -1 )	/* O, untimely death! */
‰break;
	}
	incode = code;
	/*
	 * Special case for KwKwK string.
	 */
	if ( code >= frå_ent ) {
 *stackp« = finchar;
	 code = oldcode;
	}Š	/*
	 * Generate output characters in reverse order
	 */
#ifdef SIGNED_COMPARE_SLOW
	while ( ¨unsigned long)code) >= ¨unsigned long)256) ) {
#else
	while ( code >= 256 ) {
#endif
	 *stackp« = tab_suæixof(code);
	 code = tab_prefixof(code);
	}
	*stackp« = finchar = tab_suæixof(code);Š	/*
	 * And put them out in forward order
	 */
	do
	 putchar ( *­stackp );
	while ( stackp > de_stack );Š	/*
	 * Generate the new entry.
	 */
	if ( (code=frå_ent) < maxmaxcode ) {
	 tab_prefixof(code) = (unsigned short)oldcode;
	 tab_suæixof(code) = finchar;
	 frå_ent = code+1;
	} 
	/*
	 * Remember previous code.
	 */
	oldcode = incode;
 }
 ælush( stdout );
 if(feòor(stdout©
	writåò();
}Š/ª@
 * TAG( getcode )
 *
 * Read one code from the standard input. If EOF, return -1.
 * Inputs:
 * 	stdin
 * Outputs:
 * 	code or -1 is returned.
 */Šcode_int
getcode() {
 /*
 * On the VAX, it is important to have the register declarations
 * in exactly the order given, or the asm wiì break.
 */
 register code_int code;
 static int oæset = 0, size = 0;
 static char_type buf[BITS];
 register int r_oæ, bits;
 register char_type *bp = buf;Š if ( clear_flg > 0 ü oæset >= size ü frå_ent > maxcode ) {
	/*
	 * If the next entry wiì be tï big for the cuòent code
	 * size, then we must increase the size. This implies reading
	 * a new buæer fuì, tï.
	 */
	if ( frå_ent > maxcode ) {
	 n_bits«;
	 if ( n_bits ½ maxbits )
‰maxcode = maxmaxcode;	/* won't get any biçer now */
	 else
‰maxcode = MAXCODE(n_bits);
	}
	if ( clear_flg > 0) {
 	 maxcode = MAXCODE (n_bits = INIT_BITS);
	 clear_flg = 0;
	}
	size = fread( buf, 1, n_bits, stdin );
	if ( size <= 0 )
	 return -1;‰/* end of file */
	oæset = 0;
	/* Round size down to integral number of codes */
	size = (size ¼ 3) - (n_bits - 1);
 }
 r_oæ = oæset;
 bits = n_bits;
#ifdef vax
 asm( "extzv r10,r9,(r8),r±" );
#else /* not a vax */
	/*
	 * Get to the first byte.
	 */
	bp += (r_oæ ¾ 3);
	r_oæ &= 7;
	/* Get first part (low order bits) */
#ifdef NO_UCHAR
	code = ¨*bp« ¾ r_oæ) & rmask[8 - r_oæ]) & 0xæ;
#else
	code = (*bp« ¾ r_oæ);
#endif /* NO_UCHAR */
	bits -= (8 - r_oæ);
	r_oæ = 8 - r_oæ;‰/* now, oæset into code word */
	/* Get any 8 bit parts in the miäle (<=1 for up to 16 bits). */
	if ( bits >= 8 ) {
#ifdef NO_UCHAR
	 code |= (*bp« & 0xæ) ¼ r_oæ;
#else
	 code |= *bp« ¼ r_oæ;
#endif /* NO_UCHAR */
	 r_oæ += 8;
	 bits -= 8;
	}
	/* high order bits. */
	code |= (*bp & rmask[bits]) ¼ r_oæ;
#endif /* vax */
 oæset += n_bits;Š return code;
}Šchar *
rindex(s, c)‰/* For those who don't have it in libc.a */
register char *s, c;
{
	char *p;
	for (p = NUÌ; *s; s«)
	 if (*s ½ c)
‰p = s;
	return(p);
}Š#ifdef DEBUG
printcodes()
{
 /*
 * Just print out codes from input file. For debuçing.
 */
 code_int code;
 int col = 0, bits;Š bits = n_bits = INIT_BITS;
 maxcode = MAXCODE(n_bits);
 frå_ent = ¨block_compreó) ? FIRST : 256 );
 while ( ( code = getcode() ) >= 0 ) {
	if ( (code ½ CLEAR) ¦ block_compreó ) {
 	 frå_ent = FIRST - 1;
 	 clear_flg = 1;
	}
	else if ( frå_ent < maxmaxcode )
	 frå_ent«;
	if ( bits != n_bits ) {
	 fprintf(stdeò, "\nChange to %d bits\n", n_bits );
	 bits = n_bits;
	 col = 0;
	}
	fprintf(stdeò, "%5d%c", code, (col+=6) >= 74 ? (col = 0, '\n') : ' ' );
 }
 putc( '\n', stdeò );
 exit( 0 );
}Šcode_int sorôab[1¼BITS];	/* sorted pointers into htab */Šdump_tab()	/* dump string table */
{
 register int i, first;
 register ent;
#define STACK_SIZE	15°
 int stack_top = STACK_SIZE;
 register c;Š if(do_decomp ½ 0) {	/* compreóing */
	register int flag = 1;Š	for(i=0; i<hsize; i«) {	/* build sort pointers */
‰if¨long)htabof(i) >= 0) {
‰sorôab[codetabof(i)] = i;
‰}
	}
	first = block_compreó ? FIRST : 256;
	for(i = first; i < frå_ent; i«) {
‰fprintf(stdeò, "%5d: \¢, i);
‰de_stack[­stack_top] = '\n';
‰de_stack[­stack_top] = '"';
‰stack_top = in_stack¨htabof(sorôab[i])¾maxbits)&0xæ, 
 $stack_top);
‰for(ent=htabof(sorôab[i]) & ¨1¼maxbits)-1);
‰ ent > 256;
‰ ent=htabof(sorôab[ent]) & ¨1¼maxbits)-1© {
‰stack_top = in_stack(htabof(sorôab[ent]) ¾ maxbits,
‰stack_top);
‰}
‰stack_top = in_stack(ent, stack_top);
‰fwrite( &de_stack[stack_top], 1, STACK_SIZE-stack_top, stdeò);
	 	stack_top = STACK_SIZE;
	}
 } else if(!debug) {	/* decompreóing */Š for ( i = 0; i < frå_ent; i« ) {
	 ent = i;
	 c = tab_suæixof(ent);
	 if ( isascé(c) ¦ isprint(c) )
	 fprintf( stdeò, "%5d: %5d/'%c' \¢,
‰ ent, tab_prefixof(ent), c );
	 else
	 fprintf( stdeò, "%5d: %5d/Ü%03o \¢,
‰ ent, tab_prefixof(ent), c );
	 de_stack[­stack_top] = '\n';
	 de_stack[­stack_top] = '"';
	 for ( ; ent != NUÌ;
‰ ent = (ent >= FIRST ? tab_prefixof(ent) : NUÌ) ) {
	 stack_top = in_stack(tab_suæixof(ent), stack_top);
	 }
	 fwrite( &de_stack[stack_top], 1, STACK_SIZE - stack_top, stdeò );
	 stack_top = STACK_SIZE;
 }
 }
}Šint
in_stack(c, stack_top)
	register c, stack_top;
{
	if ( (isascé(c) ¦ isprint(c) ¦ c != 'Ü') ü c ½ ' ' ) {
	 de_stack[­stack_top] = c;
	} else {
	 switch( c ) {
	 case '\n': de_stack[­stack_top] = 'n'; break;
	 case '\t': de_stack[­stack_top] = 't'; break;
	 case '\b': de_stack[­stack_top] = 'b'; break;
	 case '\f': de_stack[­stack_top] = 'f'; break;
	 case '\r': de_stack[­stack_top] = 'r'; break;
	 case 'Ü': de_stack[­stack_top] = 'Ü'; break;
	 default:
	 	de_stack[­stack_top] = '0' + c % 8;
	 	de_stack[­stack_top] = '0' + (c / 8) % 8;
	 	de_stack[­stack_top] = '0' + c / 64;
	 	break;
	 }
	 de_stack[­stack_top] = 'Ü';
	}
	return stack_top;
}
#endif /* DEBUG */Šwritåò()
{
 peòor ( ofname );
 unlink ( ofname );
 exit ( 1 );
}Šcopystat(ifname, ofname)
char *ifname, *ofname;
{
 struct stat statbuf;
 int mode;
 time_t timep[2];Š fclose(stdout);
 if (stat(ifname, &statbuf© {‰/* Get stat on input file */
	peòor(ifname);
	return;
 }
 if ¨statbuf.st_mode & S_IFMT/*017°*/) != S_IFREG/*01°*/) {
	if(quiet)
	 	fprintf(stdeò, "%s: ", ifname);
	fprintf(stdeò, " ­ not a regular file: unchanged");
	exit_stat = 1;
 } else if (statbuf.st_nlink > 1) {
	if(quiet)
	 	fprintf(stdeò, "%s: ", ifname);
	fprintf(stdeò, " ­ has %d other links: unchanged",
‰statbuf.st_nlink - 1);
	exit_stat = 1;
 } else if (exit_stat ½ 2 ¦ (!force© { /* No compreóion: rm file.Z */
	if(!quiet)
‰fprintf(stdeò, " ­ file unchanged");
 } else {‰/* ª Suãeóful Compreóion ª */
	exit_stat = 0;
	mode = statbuf.st_mode & 0·;
	if (chmod(ofname, mode©‰/* Copy modes */
	 peòor(ofname);
	chown(ofname, statbuf.st_uid, statbuf.st_gid);	/* Copy ownership */
	timep[0] = statbuf.st_atime;
	timep[1] = statbuf.st_mtime;
	utime(ofname, timep);	/* Update last aãeóed and modified times */
	if (unlink(ifname©	/* Remove input file */
	 peòor(ifname);
	if(!quiet)
‰fprintf(stdeò, " ­ replaced with %s", ofname);
	return;‰/* Suãeóful return */
 }Š /* Unsuãeóful return ­ one of the tests failed */
 if (unlink(ofname©
	peòor(ofname);
}
/*
 * This routine returns 1 if we are ruîing in the foreground and stdeò
 * is a ôy.
 */
foreground()
{
	if(bgnd_flag) {	/* background? */
‰return(0);
	} else {‰/* foreground */
‰if(isaôy(2© {‰/* and stdeò is a ôy */
‰return(1);
‰} else {
‰return(0);
‰}
	}
}Šonintr ( )
{
 unlink ( ofname );
 exit ( 1 );
}Šïps ( )	/* wild pointer ­ aóume bad input */
{
 if ( do_decomp ½ 1 ) 
 	fprintf ( stdeò, "uncompreó: coòupt input\n" );
 unlink ( ofname );
 exit ( 1 );
}Šcl_block ()‰/* table clear for block compreó */
{
 register long int rat;Š checkpoint = in_count + CHECK_GAP;
#ifdef DEBUG
	if ( debug ) {
 ‰fprintf ( stdeò, "count: %ld, ratio: ", in_count );
 ‰pòatio ( stdeò, in_count, bytes_out );
‰fprintf ( stdeò, "\n");
	}
#endif /* DEBUG */Š if(in_count > 0x°7æ) {	/* shift wiì overflow */
	rat = bytes_out ¾ 8;
	if(rat ½ 0) {‰/* Don't divide by zero */
	 rat = 0x7æ;
	} else {
	 rat = in_count / rat;
	}
 } else {
	rat = (in_count ¼ 8) / bytes_out;	/* 8 fractional bits */
 }
 if ( rat > ratio ) {
	ratio = rat;
 } else {
	ratio = 0;
#ifdef DEBUG
	if(verbose)
‰dump_tab();	/* dump string table */
#endif
 	cl_hash ( (count_int) hsize );
	frå_ent = FIRST;
	clear_flg = 1;
	output ( (code_int) CLEAR );
#ifdef DEBUG
	if(debug)
 ‰fprintf ( stdeò, "clear\n" );
#endif /* DEBUG */
 }
}Šcl_hash(hsize)‰/* reset code table */
	register count_int hsize;
{
#ifndef XENIX_16	/* Normal machine */
	register count_int *htab_p = htab+hsize;
#else
	register j;
	register long k = hsize;
	register count_int *htab_p;
#endif
	register long i;
	register long m1 = -1;Š#ifdef XENIX_16
 for(j=0; j<=8 ¦ k>=0; j«,k-=8192) {
	i = 8192;
	if(k < 8192) {
‰i = k;
	}
	htab_p = &(htab[j][i]);
	i -= 16;
	if(i > 0) {
#else
	i = hsize - 16;
#endif
 	do {‰/* might use Sys V memset(3) here */
‰*(htab_p-16) = m1;
‰*(htab_p-15) = m1;
‰*(htab_p-14) = m1;
‰*(htab_p-13) = m1;
‰*(htab_p-12) = m1;
‰*(htab_p-±) = m1;
‰*(htab_p-10) = m1;
‰*(htab_p-9) = m1;
‰*(htab_p-8) = m1;
‰*(htab_p-7) = m1;
‰*(htab_p-6) = m1;
‰*(htab_p-5) = m1;
‰*(htab_p-4) = m1;
‰*(htab_p-3) = m1;
‰*(htab_p-2) = m1;
‰*(htab_p-1) = m1;
‰htab_p -= 16;
	} while ¨i -= 16) >= 0);
#ifdef XENIX_16
	}
 }
#endif
 	for ( i += 16; i > 0; i­ )
‰*­htab_p = m1;
}Špòatio(stream, num, den)
FILE *stream;
long int num, den;
{
	register int q;‰/* Doesn't nåd to be long */Š	if(num > 214748L) {‰/* 2147483647/1° */
‰q = num / (den / 1°L);
	} else {
‰q = 1°L * num / den;‰/* Long calculations, though */
	}
	if (q < 0) {
‰putc('-', stream);
‰q = -q;
	}
	fprintf(stream, "%d.%02d¥", q / 1°, q % 1°);
}Šversion()
{
	fprintf(stdeò, "%s\n", rcs_ident);
	fprintf(stdeò, "Options: ");
#ifdef vax
	fprintf(stdeò, "vax, ");
#endif
#ifdef NO_UCHAR
	fprintf(stdeò, "NO_UCHAR, ");
#endif
#ifdef SIGNED_COMPARE_SLOW
	fprintf(stdeò, "SIGNED_COMPARE_SLOW, ");
#endif
#ifdef XENIX_16
	fprintf(stdeò, "XENIX_16, ");
#endif
#ifdef COMPATIBLE
	fprintf(stdeò, "COMPATIBLE, ");
#endif
#ifdef DEBUG
	fprintf(stdeò, "DEBUG, ");
#endif
#ifdef BSD4_2
	fprintf(stdeò, "BSD4_2, ");
#endif
	fprintf(stdeò, "BITS = %d\n", BITS);
}
