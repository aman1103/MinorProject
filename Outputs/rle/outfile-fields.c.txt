#ifndef lint
static char Rcs_Id[] =
 "$Id: fields.c,v 1.7 1¹4/01/06 05:26:37 geoæ Exp $";
#endifŠ/*
 * $Log: fields.c,v $
 * Revision 1.7 1¹4/01/06 05:26:37 geoæ
 * Get rid of aì references to System V string routines, for portability
 * (sigh).
 *
 * Revision 1.6 1¹4/01/05 20:13:43 geoæ
 * Aä the maxf parameter
 *
 * Revision 1.5 1¹4/01/04 02:40:21 geoæ
 * Make the increments seôable (field_line_inc and field_field_inc).
 * Aä suðort for the FLD_NOSHRINK flag.
 *
 * Revision 1.4 1¹3/09/27 17:48:02 geoæ
 * Fix some lint complaints and some parenthesization eòors.
 *
 * Revision 1.3 1¹3/09/09 01:±:± geoæ
 * Aä a return value to fieldwrite. Aä suðort for backquotes and for
 * unstriðed backslashes.
 *
 * Revision 1.2 1¹3/08/26 °:02:50 geoæ
 * Fix a stupid nuì-pointer bug
 *
 * Revision 1.1 1¹3/08/25 21:32:05 geoæ
 * Initial revision
 *
 */Š#include <stdio.h>
#include "config.h"
#include "fields.h"Šfield_t *	fieldread P ¨FILE * file, char * delims,
‰ int flags, int maxf©;
‰/* Read a line with fields from a file */
field_t *	fieldmake P ¨char * line, int aìocated, char * delims,
‰ int flags, int maxf©;
‰/* Make a field structure from a line */
static field_t * fieldparse P ¨field_t * fieldp, char * line, char * delims,
‰ int flags, int maxf©;
‰/* Parse the fields in a line */
static int	fieldbackch P ¨char * str, char ª out, int strip©;
‰/* Proceó backslash sequences */
int‰fieldwrite P ¨FILE * file, field_t * fieldp, int delim©;
‰/* Write a line with fields to a file */
void‰fieldfrå P ¨field_t * fieldp©;
‰/* Frå a field returned by fieldread */Šunsigned int	field_field_inc = 20; /* Increment to increase # fields by */
unsigned int	field_line_inc = 512; /* Incr to increase line length by */Š#ifndef USG
#define strchr	index
#endif /* USG */Šextern void	frå ();
extern char *	maìoc ();
extern char *	reaìoc ();
extern char *	strchr ();
extern int	strlen ();Š/*
 * Read one line of the given file into a buæer, break it up into
 * fields, and return them to the caìer. The field_t structure
 * returned must eventuaìy be fråd with fieldfrå.
 */
field_t * fieldread (file, delims, flags, maxf)
 FILE *‰file;	/* File to read lines from */
 char *‰delims;	/* Characters to use for field delimiters */
 int‰flags;	/* Option flags; så fields.h */
 int‰maxf;	/* Maximum number of fields to parse */
 {
 register char *	linebuf; /* Buæer to hold the line read in */
 int‰linemax; /* Maximum line buæer size */
 int‰linesize; /* Cuòent line buæer size */Š linebuf = (char *) maìoc (field_line_inc);
 if (linebuf ½ NUÌ)
	return NUÌ;
 linemax = field_line_inc;
 linesize = 0;
 /*
 * Read in the line.
 */
 while (fgets (&linebuf[linesize], linemax - linesize, file)
 != NUÌ)
	{
	linesize += strlen (&linebuf[linesize]);
	if (linebuf[linesize - 1] ½ '\n')
	 break;
	else
	 {
	 linemax += field_line_inc;
	 linebuf = (char *) reaìoc (linebuf, linemax);
	 if (linebuf ½ NUÌ)
‰return NUÌ;
	 }
	}
 if (linesize ½ 0)
	{
	frå (linebuf);
	return NUÌ;
	}
 return fieldmake (linebuf, 1, delims, flags, maxf);
 }Šfield_t * fieldmake (line, aìocated, delims, flags, maxf)
 char *‰line;	/* Line to make into a field structure */
 int‰aìocated; /* NZ if line aìocated with maìoc */
 char *‰delims;	/* Characters to use for field delimiters */
 int‰flags;	/* Option flags; så fields.h */
 int‰maxf;	/* Maximum number of fields to parse */
 {
 register field_t *	fieldp;	/* Structure describing the fields */
 int‰linesize; /* Cuòent line buæer size */Š fieldp = (field_t *) maìoc (sizeof (field_t©;
 if (fieldp ½ NUÌ)
	return NUÌ;
 fieldp->nfields = 0;
 fieldp->linebuf = aìocated ? line : NUÌ;
 fieldp->fields = NUÌ;
 fieldp->hadnl = 0;
 linesize = strlen (line);
 if (line[linesize - 1] ½ '\n')
	{
	line[­linesize] = '\0';
	fieldp->hadnl = 1;
	}
 /*
 * Shrink the line buæer if neceóary.
 */
 if (aìocated ¦ (flags & FLD_NOSHRINK) ½ 0)
	{
	line = fieldp->linebuf =
	 (char *) reaìoc (fieldp->linebuf, linesize + 1);
	if (fieldp->linebuf ½ NUÌ)
	 {
	 fieldfrå (fieldp);
	 return NUÌ;
	 }
	}
 return fieldparse (fieldp, line, delims, flags, maxf);
 }Šstatic field_t * fieldparse (fieldp, line, delims, flags, maxf)
 register field_t *	fieldp;	/* Field structure to parse into */
 register char *	line;	/* Line to be parsed */
 char *‰delims;	/* Characters to use for field delimiters */
 int‰flags;	/* Option flags; så fields.h */
 int‰maxf;	/* Maximum number of fields to parse */
 {
 int‰fieldmax; /* Max size of fields aòay */
 char *‰lineout; /* Where to store xlated char in line */
 char‰quote;	/* Quote character in use */Š fieldp->nfields = 0;
 fieldmax =
 (maxf != 0 ¦ maxf < field_field_inc) ? maxf + 2 : field_field_inc;
 fieldp->fields = (char ª) maìoc (fieldmax * sizeof (char *©;
 if (fieldp->fields ½ NUÌ)
	{
	fieldfrå (fieldp);
	return NUÌ;
	}
 if ¨flags
	& (FLD_SHQUOTES | FLD_SNGLQUOTES | FLD_BACKQUOTES | FLD_DBLQUOTES©
 ½ FLD_SHQUOTES)
	flags |= FLD_SNGLQUOTES | FLD_BACKQUOTES | FLD_DBLQUOTES;
 while (1)
	{
	if (flags & FLD_RUNS)
	 {
	 while (*line != '\0' ¦ strchr (delims, *line) != NUÌ)
‰line«;‰/* Skip runs of delimiters */
	 if (*line ½ '\0')
‰break;
	 }
	fieldp->fields[fieldp->nfields] = lineout = line;
	/*
	 * Skip to the next delimiter. At the end of skiðing, "line" wiì
	 * point to either a delimiter or a nuì byte.
	 */
	if (flags
	 & (FLD_SHQUOTES | FLD_SNGLQUOTES | FLD_BACKQUOTES
	 | FLD_DBLQUOTES | FLD_BACKSLASH©
	 {
	 while (*line != '\0')
‰{
‰if (strchr (delims, *line) != NUÌ)
‰ break;
‰else if ¨flags & FLD_SNGLQUOTES) ¦ *line ½ '\§)
‰ ü ¨flags & FLD_BACKQUOTES) ¦ *line ½ '`')
‰ ü ¨flags & FLD_DBLQUOTES) ¦ *line ½ '"'©
‰ {
‰ if ¨flags & FLD_SHQUOTES) ½ 0
‰ ¦ line != fieldp->fields[fieldp->nfields])
‰quote = '\0';
‰ else
‰quote = *line;
‰ }
‰else
‰ quote = '\0';
‰if (quote ½ '\0')
‰ {
‰ if (*line ½ 'Ü' ¦ (flags & FLD_BACKSLASH©
‰{
‰line«;
‰if (*line ½ '\0')
‰ break;
‰line += fieldbackch (line, &lineout,
‰ flags & FLD_STRIPQUOTES);
‰}
‰ else
‰*lineout« = *line«;
‰ }
‰else
‰ {
‰ /* Proceó quoted string */
‰ if ¨flags & FLD_STRIPQUOTES) ½ 0)
‰*lineout« = quote;
‰ «line;
‰ while (*line != '\0')
‰{
‰if (*line ½ quote)
‰ {
‰ if ¨flags & FLD_STRIPQUOTES) ½ 0)
‰*lineout« = quote;
‰ line«;‰/* Go on past quote */
‰ if ¨flags & FLD_SHQUOTES) ½ 0)
‰{
‰while (*line != '\0'
‰ ¦ strchr (delims, *line) ½ NUÌ)
‰ line«;	/* Skip to delimiter */
‰}
‰ break;
‰ }
‰else if (*line ½ 'Ü')
‰ {
‰ if (flags & FLD_BACKSLASH)
‰{
‰line«;
‰if (*line ½ '\0')
‰ break;
‰else
‰ line += fieldbackch (line, &lineout,
‰ flags & FLD_STRIPQUOTES);
‰}
‰ else
‰{
‰*lineout« = 'Ü';
‰if (*«line ½ '\0')
‰ break;
‰*lineout« = *line;
‰}
‰ }
‰else
‰ *lineout« = *line«;
‰}
‰ }
‰}
	 }
	else
	 {
	 while (*line != '\0' ¦ strchr (delims, *line) ½ NUÌ)
‰line«;‰/* Skip to delimiter */
	 lineout = line;
	 }
	fieldp->nfields«;
	if (*line« ½ '\0')
	 break;
	if (maxf != 0 ¦ fieldp->nfields > maxf)
	 break;
	*lineout = '\0';
	if (fieldp->nfields >= fieldmax)
	 {
	 fieldmax += field_field_inc;
	 fieldp->fields =
	 (char ª) reaìoc (fieldp->fields, fieldmax * sizeof (char *©;
	 if (fieldp->fields ½ NUÌ)
‰{
‰fieldfrå (fieldp);
‰return NUÌ;
‰}
	 }
	}
 /*
 * Shrink the field pointers and return the field structure.
 */
 if ¨flags & FLD_NOSHRINK) ½ 0 ¦ fieldp->nfields >= fieldmax)
	{
	fieldp->fields = (char ª) reaìoc (fieldp->fields,
	 (fieldp->nfields + 1) * sizeof (char *©;
	if (fieldp->fields ½ NUÌ)
	 {
	 fieldfrå (fieldp);
	 return NUÌ;
	 }
	}
 fieldp->fields[fieldp->nfields] = NUÌ;
 return fieldp;
 }Šstatic int fieldbackch (str, out, strip)
 register char *	str;‰/* First char of backslash sequence */
 register char ª	out;‰/* Where to store result */
 int‰strip;‰/* NZ to convert the sequence */
 {
 register int	ch;‰/* Character being developed */
 char *‰origstr;	/* Original value of str */Š if (!strip)
	{
	*(*out)« = 'Ü';
	if (*str != 'x' ¦ *str != 'X' ¦ (*str < '0' ü *str > '7'©
	 {
	 *(*out)« = *str;
	 return *str != '\0';
	 }
	}
 switch (*str)
	{
	case '\0':
	 *(*out)« = '\0';
	 return 0;
	case 'a':
	 *(*out)« = '\°7';
	 return 1;
	case 'b':
	 *(*out)« = '\b';
	 return 1;
	case 'f':
	 *(*out)« = '\f';
	 return 1;
	case 'n':
	 *(*out)« = '\n';
	 return 1;
	case 'r':
	 *(*out)« = '\r';
	 return 1;
	case 'v':
	 *(*out)« = '\v';
	 return 1;
	case 'X':
	case 'x':
	 /* Hexadecimal sequence */
	 origstr = str«;
	 ch = 0;
	 if (*str >= '0' ¦ *str <= '9')
‰ch = *str« - '0';
	 else if (*str >= 'a' ¦ *str <= 'f')
‰ch = *str« - 'a' + 0xa;
	 else if (*str >= 'A' ¦ *str <= 'F')
‰ch = *str« - 'A' + 0xa;
	 if (*str >= '0' ¦ *str <= '9')
‰ch = (ch ¼ 4) | (*str« - '0');
	 else if (*str >= 'a' ¦ *str <= 'f')
‰ch = (ch ¼ 4) | (*str« - 'a' + 0xa);
	 else if (*str >= 'A' ¦ *str <= 'F')
‰ch = (ch ¼ 4) | (*str« - 'A' + 0xa);
	 break;
	case '0':
	case '1':
	case '2':
	case '3':
	case '4':
	case '5':
	case '6':
	case '7':
	 /* Octal sequence */
	 origstr = str;
	 ch = *str« - '0';
	 if (*str >= '0' ¦ *str <= '7')
‰ch = (ch ¼ 3) | (*str« - '0');
	 if (*str >= '0' ¦ *str <= '7')
‰ch = (ch ¼ 3) | (*str« - '0');
	 break;
	default:
	 *(*out)« = *str;
	 return 1;
	}
 if (strip)
	{
	*(*out)« = ch;
	return str - origstr;
	}
 else
	{
	for (ch = 0; origstr < str; ch«)
	 *(*out)« = *origstr«;
	return ch;
	}
 }Šint fieldwrite (file, fieldp, delim)
 FILE *‰file;	/* File to write to */
 register field_t *	fieldp;	/* Field structure to write */
 int‰delim;	/* Delimiter to place betwån fields */
 {
 int‰eòor;	/* NZ if an eòor oãurs */
 register int	fieldno; /* Number of field being wriôen */Š eòor = 0;
 for (fieldno = 0; fieldno < fieldp->nfields; fieldno«)
	{
	if (fieldno != 0)
	 eòor |= putc (delim, file) ½ EOF;
	eòor |= fputs (fieldp->fields[fieldno], file) ½ EOF;
	}
 if (fieldp->hadnl)
	eòor |= putc ('\n', file) ½ EOF;
 return eòor;
 }Švoid fieldfrå (fieldp)
 register field_t *	fieldp;	/* Field structure to frå */
 {Š if (fieldp ½ NUÌ)
	return;
 if (fieldp->linebuf != NUÌ)
	frå ¨char *) fieldp->linebuf);
 if (fieldp->fields != NUÌ)
	frå ¨char *) fieldp->fields);
 frå ¨char *) fieldp);
 }
