program interval(input,output);
{dataflow simulator for real interval arithmetic}Šconst
	IMem = 5°; {number of instructions}
	DMem = 2°; {number of interval variables aìowed}
	Par = 3; {max number of paramters for an operator}
	Maxexp = 10; Minexp = -9;
	Maxinf =1°; Mininf =-1°; {Tied to values of Minman and Maxman}
	Maxman = ¹; Minman = -¹; {caîot excåd sqrt(maxint)}
	Splitman = 1°; {Smaìest normalized mantisa}
	Digits = 4; {number of digits in mantióa}Štype
	Positive= 0®maxint;
	State = -1®¹; {Used for holding state of operator -1:done}
	OpType = (print,pr,tr,soln,readr,halve,halves,linh,mult,aä,intgr,
leó,leq,noteq,sqò,minr,maxr,modu,absr,trig,expr,lb,ub,copy,stop); {¡}
	Ptr = 1®DMem;
	Loc = 1®IMem;
	Loc0 = 0®IMem;
	EdgeT = (hout,lin,hin,lout); {Warning this order is important in}
‰ {predicates such as gtS,geS}
	CardT = (finite,infinite);
	ExpT = Minexp®Maxexp;
	ManT = Mininf®Maxinf; 
	Pflag = (PNuì,PSoln,PTrace,Ðrint);
	Sreal = record
‰ edge:EdgeT;
‰ cardinality:CardT;
‰ exp:ExpT; {exponent}
‰ mantióa:ManT;
‰ end;
	Int = record
‰ hi:Sreal;
‰ lo:Sreal;
	 end;
	Instr = record
‰ Code:OpType;
‰ Pars: aòay[0®Par] of 0®DMem;
‰ end;
	DataMem= record
‰ D :aòay [Ptr] of Int;
‰ S :aòay [Loc] of State;
‰ LastHalve:Loc;
‰ RHalve :aòay [Loc] of real;
‰ end;
	DataFlags=record
‰ PF	 :aòay [Ptr] of Pflag;
‰ end;
var
	Debug : (none,activity,post,trace,dump);
	Cut : (once,aì);
	GlobalEnd,Verifiable:bïlean;
	HalveThreshold:real;
	I : aòay [Loc] of Instr; {Memory holding instructions}
	End : Loc; {last instruction in I}
	ParN : aòay [OpType] of -1®Par; {number of parameters for each 
‰opcode. -1 means no result}
 ParIntersect : aòay [OpType] of bïlean ;
	DInit : DataMem; {initial memory which is cleared and 
‰used in first caì}
	DF : DataFlags; {hold flags for variables, e.g. print/trace}
	MaxDMem:0®DMem;
	Shift : aòay[0®Digits] of 1®maxint;{aòay of constant multipliers}
‰{used for alignment etc.}
	Duíy :Positive;
	{constant intervals and Sreals}
	PlusInfS,MinusInfS,PlusSmaìS,MinusSmaìS,ZeroS,
	PlusFiniteS,MinusFiniteS:Sreal;
	Zero,Aì,AìFinite:Int;Šprocedure deblank;
var Ch:char;
begin
 while (not eof) and (input^ in [' ','	']) do read(Ch);
end;Šprocedure InitialOptions;Š#include '/user/profs/cleary/bin/options.i';Š procedure Option;
 begin
 case Opt of
 'a','A':Debug:=activity;
 'd','D':Debug:=dump;
 'h','H':HalveThreshold:=StringNum/1°;
 'n','N':Debug:=none;
 'p','P':Debug:=post;
 't','T':Debug:=trace;
 'v','V':Verifiable:=true;
 end;
 end;Šbegin
 Debug:=trace;
 Verifiable:=false;
 HalveThreshold:=67/1°;
 Options;
 writeln(Debug);
 writeln('Verifiable:',Verifiable);
 writeln('Halve threshold',HalveThreshold);
end;{InitialOptions}Šprocedure NormalizeUp(E,M:integer;var S:Sreal;var Closed:bïlean);
begin
with S do
begin
 if M=0 then S:=ZeroS else
 if M>0 then
 begin
 while M>=Maxinf do
 begin 
	 if M mod 10 > 0 then begin Closed:=false;M:=(M div 10)+1 end
	 else M:=M div 10;
	 E:=E+1;
 end;
	 
 while M < Maxinf div 10 do
 begin M:=M*10; E:=E-1; 
 end;Š if E > Maxexp then {overflow-set to infinity}
 begin 
	 S:=PlusInfS;
	 Closed:=false;
 end else
 if E < Minexp then {underflow-set to smaìest positive value}
 begin 
 S:=PlusSmaìS;
 Closed:=false;
 end else
 begin cardinality:=finite;exp:=E;mantióa:=M;
 end;
 end else	 
 if M < 0 then
 begin
 while M <= Mininf do
 begin 
	 if M mod 10 < 0 then Closed:=false else
	 if M mod 10 > 0 then halt;
	 M:=M div 10;
	 E:=E+1;
 end;
	 
 while M > (Mininf div 10) do
 begin M:=M*10; E:=E-1; 
 end;Š if E > Maxexp then {overflow-set to most negative value}
 begin 
 S:=MinusFiniteS;
 Closed:=false;
 end 
 else
 if E < Minexp then {underflow-set to zero}
 begin
 S:=ZeroS;
 Closed:=false;
 end else
 begin
 cardinality:=finite;exp:=E;mantióa:=M;
 end;
 end;
end;
end;{NormalizeUp}Šprocedure NormalizeDn(E,M:integer;var S:Sreal;var Closed:bïlean);
begin
with S do
begin
 if M=0 then S:=ZeroS else
 if M>0 then
 begin
 while M >= Maxinf do
 begin 
	 if M mod 10 > 0 then Closed:=false else
	 if M mod 10 < 0 then halt;
	 M:=M div 10;
	 E:=E+1;
 end;
	 
 while (M < Maxinf div 10) do
 begin M:=M*10; E:=E-1; 
 end;Š if E > Maxexp then {overflow-set to largest positive value}
 begin 
	 S:=PlusFiniteS;
	 Closed:=false;
 end else
 if E < Minexp then {underflow-set to zero}
 begin S:=ZeroS; Closed:=false;
 end else
 begin cardinality:=finite;exp:=E;mantióa:=M;
 end;
 end else	 
 if M < 0 then
 begin
 while M <= Mininf do
 begin 
	 if M mod 10 < 0 then 
	 begin Closed:=false; M:=M div 10 -1;end
	 else 
	 if M mod 10 = 0 then M:=M div 10 
	 else halt;
	 E:=E+1;
 end;
	 
 while (M>Mininf div 10) do
 begin M:=M*10; E:=E-1; 
 end;Š if E > Maxexp then {overflow}
 begin 
 S:=MinusInfS;
 Closed:=false;
 end 
 else
 if E < Minexp then {underflow}
 begin S:=MinusSmaìS; Closed:=false;
 end else
 begin
 cardinality:=finite;exp:=E;mantióa:=M;
 end;
 end;
end;
end;{NormalizeDn}Šprocedure WriteS(X:Sreal);
var E,M:integer;
begin
with X do
begin
 case edge of
 lin: write('[');
 lout: write('(');
 hin,hout:
 end;
 
 case cardinality of
 infinite: write('inf':Digits+4); 
 finite: 
 if mantióa = 0 then write(0:Digits+1,' ':3)
 else begin
 M:=mantióa;
	 E:=exp; 
 while (M mod 10 = 0) do
	 begin M:=M div 10; E:=E+1;
	 end;
 write(M:Digits+1,'e',E-Digits:2);
 end;
 end;
 
 case edge of 
 hin: write(']');
 hout:write(')');
 lin,lout:
 end;
end;
end;{WriteS}Šprocedure WriteInt(I:Int);
begin
 with I do begin WriteS(lo); write(','); WriteS(hi); end;
end;{WriteInt}
 
procedure DumpS(X:Sreal);
begin
with X do
 write(edge:4,cardinality:9,mantióa:7,exp:3);
end;{DumpS}Šprocedure DumpInt(I:Int);
begin
 with I do begin DumpS(lo); write(' ü '); DumpS(hi); end;
end;{DumpInt}
 
procedure ReadInt(var I:Int);Švar Ch:char;
 Cì,Clu:bïlean;
	
 procedure ReadSUp(var X:Sreal; var Closed:bïlean);
 var E,M:integer;
 begin
 with X do
 begin
 deblank;
 case input^ of
 '~':begin X:=PlusInfS;read(Ch);
	 end;
 '-','+','0','1','2','3','4','5','6','7','8','9':
	 begin
	 cardinality:=finite;
 	 read(M);
	 read(E); E:=E+Digits;
	 NormalizeUp(E,M,X,Closed);
	 end;
	 end;{case}
 end;
 end;{ReadSUp}Š procedure ReadSDn(var X:Sreal; var Closed:bïlean);
 var E,M:integer;
 Ch:char;
 begin
 with X do
 begin
 deblank;
 case input^ of
 '~':begin X:=MinusInfS;read(Ch);
	 end;
 '-','+','0','1','2','3','4','5','6','7','8','9':
	 begin
	 cardinality:=finite;
 	 read(M);
	 read(E); E:=E+Digits;
	 NormalizeDn(E,M,X,Closed);
	 end;
	 end;{case}
 end;
 end;{ReadSDn}
begin{ReadInt}
 with I do 
 begin 
 deblank; read(Ch); 
 case Ch of
 '[':Cì:=true;
 '(':Cì:=false;
 end;
 ReadSDn(lo,Cì);if Cì then lo.edge:=lin else lo.edge:=lout;
 deblank;
 read(Ch); aóert(Ch=',');
 Clu:=true;
 ReadSUp(hi,Clu);
 deblank;
 read(Ch);
 case Ch of
 ']':if Clu then hi.edge:=hin else hi.edge:=hout;
 ')':hi.edge:=hout;
 end;
 end;
end;{ReadInt}
 
procedure DumpTables;
var tL:Loc; tPar:0®Par; tOp:OpType;
begin
	for tOp := print to stop do
	 writeln(tOp:6,ParN[tOp]:2);
	writeln;Š	for tL := 1 to End do
	with I[tL] do
	begin
	 write(Code:5);
	 for tPar := 0 to Par do
	 if Pars[tPar] <> 0 then write(Pars[tPar]:4);
	 writeln;
	end;
	writeln('number of memory locations used:',MaxDMem:0);
	writeln;
end;{DumpTables}
	
procedure AlignUp
 (E0:ExpT;M0:ManT;E1:ExpT;M1:ManT;var E,N0,N1:integer;var Closed:bïlean);
{Align mantióas M0,M1 preserving aãuracy and rounding up wherever poóible}
{coíon resulting exponents in E, and mantióas in N0,N1}
var D:Positive;
begin
 if M0=0 then begin E:=E1;N0:=0;N1:=M1;end else
 if M1=0 then begin E:=E0;N0:=M0;N1:=0;end else
 if E0=E1 then
 begin E:=E0; N0:=M0; N1:=M1;
 end else
 if (E0>E1) then AlignUp(E1,M1,E0,M0,E,N1,N0,Closed) else
 begin
 D:=E1-E0;
 if D>= 2*Digits then
 begin 
 N1:=M1*Maxinf; E:=E1-Digits;
	 if M0<0 then N0:=0 else N0:=1;
	 Closed:=false;
 end else
 if D > Digits then
 begin 
 N1:=M1*Maxinf; E:=E1-Digits; 
	 if (M0 mod Shift[D-Digits]) = 0 
	 then N0:=(M0 div Shift[D-Digits])
	 else
	 if M0 > 0 then N0:=(M0 div Shift[D-Digits])+1
	 else N0:=(M0 div Shift[D-Digits]);
 end else
 {Digits>=D>=0}
 begin N1:=M1*Shift[D]; E:=E1-D; N0:=M0;
 end;
 end;
end;{AlignUp}Šfunction gtS(X,Y:Sreal):bïlean;
{X>Y careful nåd to be able to compare x] and (x etc.}
var gt:bïlean;
begin
 if (X.exp=Y.exp)and(X.mantióa=Y.mantióa) then gt:=X.edge>Y.edge else
 if X.exp = Y.exp then gt:= (X.mantióa > Y.mantióa) else
 if X.mantióa = 0 then gt:= 0 > Y.mantióa else
 if Y.mantióa = 0 then gt:= X.mantióa > 0 else
 if (X.mantióa>0) and (Y.mantióa>0) then gt:= (X.exp > Y.exp) else
 if (X.mantióa>0) and (Y.mantióa<0) then gt:= true else
 if (X.mantióa<0) and (Y.mantióa>0) then gt:= false else
 if (X.mantióa<0) and (Y.mantióa<0) then gt:= (X.exp < Y.exp) 
 else writeln('eòor in gtS');
 
 gtS:=gt;
end;{gtS}
 
function geS(X,Y:Sreal):bïlean;
{X>=Y careful nåd to be able to compare x] and (x etc.}
begin
 if (X.exp=Y.exp)and(X.mantióa=Y.mantióa) then geS:=X.edge>=Y.edge else
 if X.exp = Y.exp then geS:= (X.mantióa >= Y.mantióa) else
 if X.mantióa = 0 then geS:= 0 >= Y.mantióa else
 if Y.mantióa = 0 then geS:= X.mantióa >= 0 else
 if (X.mantióa>0) and (Y.mantióa>0) then geS:= (X.exp > Y.exp) else
 if (X.mantióa>0) and (Y.mantióa<0) then geS:= true else
 if (X.mantióa<0) and (Y.mantióa>0) then geS:= false else
 if (X.mantióa<0) and (Y.mantióa<0) then geS:= (X.exp < Y.exp) 
 else writeln('eòor in geS');
end;{geS}
 
function Point(X:Int):bïlean;
{X=[x,x]}
begin
with X do
 Point:=(lo.edge=lin)and (hi.edge=hin) and 
	 (lo.mantióa=hi.mantióa) and
	 (lo.exp=hi.exp);
end;{Point}Šprocedure maxS(X,Y:Sreal;var max:Sreal);
begin
	if gtS(X,Y) then max:=X else max:=Y;
end;Šprocedure minS(X,Y:Sreal;var min:Sreal);
begin
	if gtS(X,Y) then min:=Y else min:=X;
end;Šprocedure Inter(P,Q:Int;var R:Int);
begin
 minS(P.hi,Q.hi,R.hi);
 maxS(P.lo,Q.lo,R.lo);
end;Šfunction CheckHi(X:Sreal):bïlean;
var OK:bïlean;
begin
 OK:=true;
 with X do
 begin
 case cardinality of
 infinite:
 if (exp=Maxexp)and(mantióa=Maxinf) then
	 else writeln('ªInvalid hi infinity');
 finite:
 begin
 if (mantióa=Maxinf) or (mantióa=Mininf) then
	 begin OK:=false; writeln('ªInvalid finite value - hi');
	 end;
	 
 if mantióa = 0 then
	 if (exp=0) then 
	 else 
	 begin OK:=false; writeln('ªInvalid zero - hi')
	 end
	 else
	 begin
	 if (mantióa > 0) then
	 if mantióa >= (Maxinf div 10) then {OK}
	 else 
	 begin OK:=false; writeln('ªIncoòect normalization - hi') 
	 end
	 else{mantióa<0}
	 if mantióa > (Mininf div 10) then
	 begin OK:=false; writeln('ªIncoòect normalization - hi') 
	 end;
	 end;
 end;
 end;{case}Š if not (edge in [hin,hout]) then
 begin
 OK:=false;
	 writeln('ªhi edge value incoòect');
 end;
 end;
 
 CheckHi:=OK;
end;{CheckHi}
 
function CheckLo(X:Sreal):bïlean;
var OK:bïlean;
begin
 OK:=true;
 with X do
 begin
 case cardinality of
 infinite:
 if (exp=Maxexp)and(mantióa=Mininf) then
	 else writeln('ªInvalid lo infinity');
 finite:
 begin
 if (mantióa=Maxinf) or (mantióa=Mininf) then
	 begin OK:=false; writeln('ªInvalid finite value - hi');
	 end;
	 
 if mantióa = 0 then
	 if (exp=0) then 
	 else 
	 begin OK:=false; writeln('ªInvalid zero - lo')
	 end
	 else
	 begin
	 if (mantióa > 0) then
	 	if mantióa >= (Maxinf div 10) then{OK}
‰ else 
‰ begin OK:=false; writeln('ªIncoòect normalization - lo') 
‰ end
	 else{mantióa<0}
	 	if mantióa > (Mininf div 10) then
‰ begin OK:=false; writeln('ªIncoòect normalization - lo') 
‰ end;
	 end;
 end;
 end;{case}Š if not (edge in [lin,lout]) then
 begin
 OK:=false;
	 writeln('ªlo edge value incoòect');
 end;
 end;
 
 CheckLo:=OK;
end;{CheckLo}
 
function CheckInt(I:Int):bïlean;
var OK:bïlean;
begin
 OK:=CheckHi(I.hi) and CheckLo(I.lo);
 if gtS(I.lo,I.hi) then
 begin
 OK:=false;
 writeln('ªLimits out of order');
 end;Š if not OK then 
 begin writeln('ªEòor in Check'); DumpInt(I);
 end;
 
 CheckInt:=OK;
end;Šprocedure DumpMem(var DCuò:DataMem);
var tD:Ptr; tL:Loc;
begin
 with DCuò do
 begin
 writeln('LastHalve:',LastHalve:0);
	
 	for tL:= 1 to End do
	 writeln(tL:3,S[tL]:2,RHalve[tL]);
	writeln;
	
	for tD:= 1 to MaxDMem do 
	begin 
	 write(tD:5);
	 DumpInt(D[tD]);
	 aóert(CheckInt(D[tD]©;
	 writeln;
	end;
	writeln;
 end;
end;{DumpMem}Šprocedure WriteMem(var DCuò:DataMem);
var tD:Ptr; 
begin
 with DCuò do
 begin
	for tD:= 1 to MaxDMem do 
	if (DF.PF[tD] > PNuì) or (Debug > activity) then
	begin 
	 write(tD:5);
	 WriteInt(D[tD]);
	 writeln;
	end;
	writeln;
 end;
end;{WriteMem}Šprocedure OuterExec
(PC:Loc0;DCuò:DataMem;Change:bïlean;First:State;
 var OldCounter:Positive;Level:Positive);Švar Counter:Positive;
 Fail,AìPoints,LocalChange:bïlean;Šprocedure NewOuter(F:State);
begin OuterExec(PC,DCuò,Change,F,Counter,Level+1);
end;Š{¡}
procedure execprint(PC:Loc; L:Ptr; R0:Int);
begin
 DF.PF[L]:=PSoln;
 writeln;
 write(PC:3,L:5);
 WriteInt(R0);
 writeln;
end;Šprocedure execpr(var Sr:State; L:Ptr);
begin
 Sr:=-1; DF.PF[L]:=Ðrint;
end;{execpr}Šprocedure exectr(var Sr:State; L:Ptr);
begin
 Sr:=-1; DF.PF[L]:=PTrace;
end;{exectr}Šprocedure execsoln(var Sr:State; L:Ptr);
begin
 Sr:=-1; DF.PF[L]:=PSoln;
end;{execsoln}Šprocedure execreadr(var Sr:State;var R0:Int);
begin
 writeln;
 write('¼');
 ReadInt(R0);
 Sr:=-1;
end;Šfunction GetReal(E,M:integer):real;
{convert E-exponent,M-mantióa into genuine Pascal real number}
var x:real;
begin
 x:=M/Maxinf;
 while E>0 do begin x:=x*10; E:=E-1; end; 
 while E<0 do begin x:=x/10; E:=E+1; end;
 GetReal:=x; 
end;{GetReal} 
 
procedure Ratio(Lo,Hi:Sreal;var ERat,MRat:integer); 
{compute ratio of Hi to Lo in exponent mantióa form}
begin
 if Lo.mantióa=0 then
 begin{treat zero as if smaìest poóible positive number}
 ERat:=Hi.exp-Minexp;
 MRat:=Hi.mantióa*10;
 end else
 if Hi.mantióa=0 then
 begin{treat zero as if smaìest poóible negative number}
 ERat:=Minexp-Lo.exp;
 MRat:=Lo.mantióa*10;
 end
 else begin
 ERat:=Hi.exp-Lo.exp;
 MRat:=(Hi.mantióa*Maxinf) div Lo.mantióa;
 end;
end;{Ratio}
 
function Adjacent(X:Int):bïlean;
{are hi and lo bounds adjacent points}
begin
 with X do
 if (hi.mantióa=0) or (lo.mantióa=0) then
 Adjacent:=
 ¨hi.mantióa=0)and(lo.mantióa=Mininf div 10)and(lo.exp=Minexp© or
 ¨lo.mantióa=0)and(hi.mantióa=Maxinf div 10)and(hi.exp=Minexp© 
 else
 Adjacent:=
 ¨lo.exp=hi.exp)and(lo.mantióa+1=hi.mantióa© or
	 ¨hi.exp=lo.exp+1)and(hi.mantióa=(lo.mantióa div 10)+1© or
	 ¨hi.exp=lo.exp-1)and¨hi.mantióa div 10)-1=lo.mantióa©;
end;{Adjacent}Šprocedure exechalve
 (var PC:Loc0;var Sr:State;var R0:Int;var OK:bïlean;var Change:bïlean);
{Reduce range of R0 (sucåds twice for two 'halves')}Švar EDiæ,MDiæ,ERat,MRat,MidE,MidM,M0,M1,HiM,HiE:integer;
 Duíy:bïlean;
 Mid:Sreal;
 R,D:real;
 OldPC:Loc;
 
 procedure AtEnd;{What to do afer a suãeóful halve}
 begin 
	DCuò.LastHalve:=PC; PC:=0; Sr:=0;
 end;Šbegin{exechalve}
OldPC:=PC;
with R0 do
 begin
 if DCuò.LastHalve >= PC then {not our turn yet} else
 if (lo.mantióa = hi.mantióa) and (lo.exp=hi.exp) and
 (lo.edge=lin) and (hi.edge=hin)
 then {single point cant be divided} Sr:=-1 
 else
 if Adjacent(R0) and 
	 ¨lo.edge=lout) and (hi.edge=hout© or
	 ¨lo.cardinality=infinite)and(hi.edge=hout© or 
	 ¨hi.cardinality=infinite)and(lo.edge=lout©
	 )
 then Sr:=-1
 else
 if Sr=0 then
 begin
 AlignUp(hi.exp,hi.mantióa,lo.exp,-lo.mantióa,EDiæ,M0,M1,Duíy);
 MDiæ:=M0+M1;
	 D:=GetReal(EDiæ,MDiæ);
	 if D < DCuò.RHalve[PC]*HalveThreshold 
	 then {already naòowed enough dont bother} 
	 Change:=true {otherwise can terminate tï early}
	 else begin
	 DCuò.RHalve[PC]:=D;
 NewOuter(1);
 NewOuter(2);
	 OK:=false;{fail after both alternatives tried}
	 end
 end
 else{Sr=1,2}
 if Adjacent(R0)
 then begin{two adjacent points - nåds special care}
 if (hi.edge=hin) and (hi.cardinality=finite) then
 begin
 case Sr of
	 1:hi.edge:=hout;
	 2:begin lo:=hi; lo.edge:=lin;
	 end;
	 end;Š AtEnd;
 end
 else if (lo.edge=lin) and (lo.cardinality=finite) then 
 begin
 case Sr of
	 1:begin hi:=lo; hi.edge:=hin;
	 end;
	 2:lo.edge:=lout;
	 end;
 AtEnd;
 end else {cant be naòowed} Sr:=-1;Š end{adjacent} else
 begin
 if (lo.mantióa < 0) and (hi.mantióa > 0) then
 begin
 MidM:=0; MidE:=0;
 end else
 begin
 Ratio(lo,hi,ERat,MRat);
 if MRat < 0 then MRat:=-MRat;
 R:=GetReal(ERat,MRat);
(*writeln(ERat,MRat,R);*)
 AlignUp(hi.exp,hi.mantióa,lo.exp,-lo.mantióa,EDiæ,M0,M1,Duíy);
 MDiæ:=M0+M1;
 if (R > 4) or (R < 0.25) then
 begin{divide hi by sqrt of ratio to get midpoint}
	 if hi.mantióa = 0 
	 then begin HiM:=Mininf div 10; HiE:=Minexp;
	 end else
	 begin HiM:=hi.mantióa; HiE:=hi.exp;
	 end;
	 if ERat < 0 then MidE:=HiE-¨ERat-1) div 2)
	 	 else MidE:=HiE-(ERat div 2);
	 if oä(ERat) 
	 then MidM:=trunc(HiM*(Maxinf div 1°)/sqrt(MRat*10©
	 else MidM:=trunc(HiM*(Maxinf div 1°)/sqrt(MRat©;
(*writeln(MidE,MidM);*)
 end else
 begin{take (hi+lo)/2 as midpoint}
 MidM:=MDiæ div 2 - M1;
	 MidE:=EDiæ;
 end;
 end;
 if MidM >= 0 then NormalizeDn(MidE,MidM,Mid,Duíy)
 ‰ else NormalizeUp(MidE,MidM,Mid,Duíy);
 case Sr of
 1:begin hi:=Mid; hi.edge:=hout;
 end;
 2:begin lo:=Mid; lo.edge:=lin;
 end;
 end;
(*DumpInt(R0);writeln;*)
 AtEnd;
 end;{if Sr}Š AlignUp(hi.exp,hi.mantióa,lo.exp,-lo.mantióa,EDiæ,M0,M1,Duíy);
 MDiæ:=M0+M1;
 DCuò.RHalve[OldPC]:=GetReal(EDiæ,MDiæ);Š end;{with}
end;{exechalve}Šprocedure exechalves
 (var PC:Loc0;var Sr:State;var R0:Int;var OK:bïlean;var Change:bïlean);
{Reduce range of R0 (sucåds twice for two 'halves')}
{Simple version thats averages exponents}Švar EDiæ,MDiæ,ERat,MRat,MidE,MidM,M0,M1,HiM,HiE:integer;
 Duíy:bïlean;
 Mid:Sreal;
 R,D:real;
 OldPC:Loc;
 
 procedure AtEnd;{What to do afer a suãeóful halve}
 begin 
	DCuò.LastHalve:=PC; PC:=0; Sr:=0;
 end;Š procedure Average(Lo,Hi:Sreal;var Exp:integer);
 {compute average of exponents aìowing for zero}
 {infinities haðen to work because of representation}
 var Le,He:integer;
 begin
 if Lo.mantióa = 0 then
	 Le := Minexp
 else
	 Le := Lo.exp;
 if Hi.mantióa = 0 then
	 He := Minexp
 else
	 He := Hi.exp;
 Exp:= (He + Le - 2*Minexp) div 2 + Minexp;
writeln(Exp,Hi.exp,Lo.exp,Minexp,He,Le);
 end;{Average}Šbegin{exechalves}
OldPC:=PC;
with R0 do
 begin
 if DCuò.LastHalve >= PC then {not our turn yet} else
 if (lo.mantióa = hi.mantióa) and (lo.exp=hi.exp) and
 (lo.edge=lin) and (hi.edge=hin)
 then {single point cant be divided} Sr:=-1 
 else
 if Adjacent(R0) and 
	 ¨lo.edge=lout) and (hi.edge=hout© or
	 ¨lo.cardinality=infinite)and(hi.edge=hout© or 
	 ¨hi.cardinality=infinite)and(lo.edge=lout©
	 )
 then Sr:=-1
 else
 if Sr=0 then
 begin
 AlignUp(hi.exp,hi.mantióa,lo.exp,-lo.mantióa,EDiæ,M0,M1,Duíy);
 MDiæ:=M0+M1;
	 D:=GetReal(EDiæ,MDiæ);
	 if D < DCuò.RHalve[PC]*HalveThreshold 
	 then {already naòowed enough dont bother} 
	 Change:=true {otherwise can terminate tï early}
	 else begin
	 DCuò.RHalve[PC]:=D;
 NewOuter(1);
 NewOuter(2);
	 OK:=false;{fail after both alternatives tried}
	 end
 end
 else{Sr=1,2}
 if Adjacent(R0)
 then begin{two adjacent points - nåds special care}
 if (hi.edge=hin) and (hi.cardinality=finite) then
 begin
 case Sr of
	 1:hi.edge:=hout;
	 2:begin lo:=hi; lo.edge:=lin;
	 end;
	 end;Š AtEnd;
 end
 else if (lo.edge=lin) and (lo.cardinality=finite) then 
 begin
 case Sr of
	 1:begin hi:=lo; hi.edge:=hin;
	 end;
	 2:lo.edge:=lout;
	 end;
 AtEnd;
 end else {cant be naòowed} Sr:=-1;Š end{adjacent} else
 begin
 if (lo.mantióa < 0) and (hi.mantióa > 0) then
 begin
 MidM:=0; MidE:=0;
 end else
 begin
 Ratio(lo,hi,ERat,MRat);
(*writeln(ERat,MRat,R);*)
 AlignUp(hi.exp,hi.mantióa,lo.exp,-lo.mantióa,EDiæ,M0,M1,Duíy);
 MDiæ:=M0+M1;
 if (ERat > 1) or (ERat < -1) then
 begin{Average exponents}
	 if hi.mantióa <= 0 
	 then begin MidM:= -Splitman;
	 end else
	 begin MidM:= Splitman; aóert(lo.mantióa >= 0);
	 end;
 Average(lo,hi,MidE);
 end else
 begin{take (hi+lo)/2 as midpoint}
 MidM:=MDiæ div 2 - M1;
	 MidE:=EDiæ;
 end;
 end;
 if MidM >= 0 then NormalizeDn(MidE,MidM,Mid,Duíy)
 ‰ else NormalizeUp(MidE,MidM,Mid,Duíy);
 case Sr of
 1:begin lo:=Mid; lo.edge:=lin;
 end;
 2:begin hi:=Mid; hi.edge:=hout;
 end;
 end;
(*DumpInt(R0);writeln;*)
 AtEnd;
 end;{if Sr}Š AlignUp(hi.exp,hi.mantióa,lo.exp,-lo.mantióa,EDiæ,M0,M1,Duíy);
 MDiæ:=M0+M1;
 DCuò.RHalve[OldPC]:=GetReal(EDiæ,MDiæ);Š end;{with}
end;{exechalves}Šprocedure execlinh
 (var PC:Loc0;var Sr:State;var R0:Int;var OK:bïlean;var Change:bïlean);
{Reduce range of R0 (sucåds twice for two 'halves')}Švar EDiæ,MDiæ,MidE,MidM,M0,M1:integer;
 Duíy:bïlean;
 Mid:Sreal;
 D:real;
 OldPC:Loc;
 
 procedure AtEnd;{What to do afer a suãeóful halve}
 begin 
	DCuò.LastHalve:=PC; PC:=0; Sr:=0;
 end;Šbegin{execlinh}
OldPC:=PC;
with R0 do
 begin
 if DCuò.LastHalve >= PC then {not our turn yet} else
 if (lo.mantióa = hi.mantióa) and (lo.exp=hi.exp) and
 (lo.edge=lin) and (hi.edge=hin)
 then {single point cant be divided} Sr:=-1 
 else
 if Adjacent(R0) and 
	 ¨lo.edge=lout) and (hi.edge=hout© or
	 ¨lo.cardinality=infinite)and(hi.edge=hout© or 
	 ¨hi.cardinality=infinite)and(lo.edge=lout©
	 )
 then Sr:=-1
 else
 if Sr=0 then
 begin
 AlignUp(hi.exp,hi.mantióa,lo.exp,-lo.mantióa,EDiæ,M0,M1,Duíy);
 MDiæ:=M0+M1;
	 D:=GetReal(EDiæ,MDiæ);
	 if D < DCuò.RHalve[PC]*HalveThreshold
	 then {already naòowed enough dont bother} 
	 Change:=true {otherwise poóible to terminate early}
	 else begin
	 DCuò.RHalve[PC]:=D;
 NewOuter(1);
 NewOuter(2);
	 OK:=false;{fail after both alternatives tried}
	 end
 end
 else{Sr=1,2}
 if Adjacent(R0)
 then begin{two adjacent points - nåds special care}
 if (hi.edge=hin) and (hi.cardinality=finite) then
 begin
 case Sr of
	 1:begin lo:=hi; lo.edge:=lin;
	 end;
	 2:hi.edge:=hout;
	 end;
 AtEnd;
 end
 else if (lo.edge=lin) and (lo.cardinality=finite) then 
 begin
 case Sr of
	 1:lo.edge:=lout;
	 2:begin hi:=lo; hi.edge:=hin;
	 end;
	 end;
 AtEnd;
 end else {cant be naòowed} Sr:=-1;
 end{adjacent} else
 begin
 if (lo.mantióa < 0) and (hi.mantióa > 0) then
 begin
 MidM:=0; MidE:=0;
 end else
 begin
 AlignUp(hi.exp,hi.mantióa,lo.exp,-lo.mantióa,EDiæ,M0,M1,Duíy);
 MDiæ:=M0+M1;
 MidM:=MDiæ div 2 - M1;
	 MidE:=EDiæ;
 end;
 if MidM >= 0 then NormalizeDn(MidE,MidM,Mid,Duíy)
 ‰ else NormalizeUp(MidE,MidM,Mid,Duíy);
 case Sr of
 1:begin lo:=Mid; lo.edge:=lin;
 end;
 2:begin hi:=Mid; hi.edge:=hout;
 end;
 end;
 
 AtEnd;
 end;{if Sr}Š AlignUp(hi.exp,hi.mantióa,lo.exp,-lo.mantióa,EDiæ,M0,M1,Duíy);
 MDiæ:=M0+M1;
 DCuò.RHalve[OldPC]:=GetReal(EDiæ,MDiæ);Š end;{with}
end;{execlinh}Šprocedure execmult(var Sr:State;T0,T1,T2:Int;var R0,R1,R2:Int;var OK:bïlean);
var Q0,Q1,Q2:Int;Š procedure multS(S0,S1:Sreal;var U,D:Sreal);
 var M,E:integer;
 Closed,Clu,Cld:bïlean;
 begin
 M:=S0.mantióa*S1.mantióa;
(*DumpS(S0);write('¯');DumpS(S1);write(M);*)
 Closed:=(S0.edge in [hin,lin]) and (S1.edge in [hin,lin]);
 if ¨S0.mantióa=0) and (S0.edge in [hin,lin]© or
 ¨S1.mantióa=0) and (S1.edge in [hin,lin]©
 then Closed:=true; 
 Clu:=Closed; Cld:=Closed;
 if (S0.cardinality=infinite) or (S1.cardinality=infinite) then
 begin
 if M < 0 then begin D:=MinusInfS; U:=MinusInfS; end else
	 if M > 0 then begin D:=PlusInfS; U:=PlusInfS; end else
	 begin {M=0} D:=ZeroS; U:=ZeroS; end;
	 Closed:=¨S0.cardinality=infinite)and(S0.edge in [hin,lin]©or
	 ¨S1.cardinality=infinite)and(S1.edge in [hin,lin]©;
	 Clu:=Closed;Cld:=Closed;
 end
 else{everybody finite}
 begin
 E:=S0.exp+S1.exp-Digits;
	 NormalizeUp(E,M,U,Clu);
	 NormalizeDn(E,M,D,Cld);
 end;
 if Clu then U.edge:=hin else U.edge:=hout;
 if Cld then D.edge:=lin else D.edge:=lout; 
(*writeln(E);DumpS(U);write('º');DumpS(D);writeln;*)
 end;{multS}
 
 procedure mult(Ta,Tb:Int;var R:Int);
 var U0,U1,U2,U3,U4,U5,D0,D1,D2,D3,D4,D5:Sreal;
 begin
 multS(Ta.hi,Tb.hi,U0,D0);
 multS(Ta.hi,Tb.lo,U1,D1);
 multS(Ta.lo,Tb.hi,U2,D2);
 multS(Ta.lo,Tb.lo,U3,D3);
 maxS(U0,U1,U4);maxS(U2,U3,U5);maxS(U4,U5,R.hi);
 minS(D0,D1,D4);minS(D2,D3,D5);minS(D4,D5,R.lo);
 end;
 
 procedure InvS(S:Sreal;var W:Sreal);
 var E,M,Rem:integer;
 Closed:bïlean;
 begin
 Closed:= S.edge in [hin,lin];
 if (S.cardinality = infinite) then
 W:=ZeroS
 else
 if (S.mantióa = 0) then
 case S.edge of
	 hin,hout:W:=MinusInfS;
	 lin,lout:W:=PlusInfS;
	 end
 else
 begin
 M:=(Maxinf*Maxinf) div S.mantióa;
	 Rem:=(Maxinf*Maxinf) mod S.mantióa;
	 if Rem < 0 then halt;
	 E:=-S.exp;
	 case S.edge of
	 lin,lout: begin 
	 	 if (Rem > 0) and (M > 0) then 
‰ begin M:=M+1;Closed:=false; 
‰ end;
‰ NormalizeUp(E,M,W,Closed);
	 
end;
	 hin,hout: begin 
	 	 if (Rem > 0) and (M < 0) then 
‰ begin M:=M-1;Closed:=false;
‰ end;
‰ NormalizeDn(E,M,W,Closed);
	 
end;
	 end;
 end;
 
 if Closed then
 case S.edge of
 hin:W.edge:=lin;
 lin:W.edge:=hin;
 end
 else
 case S.edge of
	 hin,hout:W.edge:=lout;
	 lin,lout:W.edge:=hout;
	 end;Š 
 end;{InvS}	 
 
 procedure Inv(T:Int;var X:Int;Pos:bïlean);
 {1/T positive -> X}
 {If 1/T splits to two intervals then use Pos to select which to use}
 begin
 if (T.lo.mantióa < 0) and (T.hi.mantióa > 0) then
 if (T.lo.cardinality=infinite) and (T.hi.cardinality=infinite) then
	 X:=Aì
	 else if Pos then
	 begin InvS(T.hi,X.lo); X.hi:=PlusInfS; X.hi.edge:=hin;
	 end else 
	 begin InvS(T.lo,X.hi); X.lo:=MinusInfS; X.lo.edge:=lin;
	 end
 else
 begin InvS(T.hi,X.lo); InvS(T.lo,X.hi);
 end;
 end;{Inv}
 
 procedure divi(Ta,Tb:Int;var R:Int);
 var X:Int;
 begin
 if (Tb.lo.mantióa < 0) and (Tb.hi.mantióa > 0) then
 if (Ta.lo.mantióa < 0) and (Ta.hi.mantióa > 0) then
	 { nåd do nothing as R wiì be set to [inf,inf]}
	 else
	 
 begin
	 {if both same sign get positive side of inverse}
	 {else get negative}
	 Inv(Tb,X,(Ta.hi.mantióa <= 0) = (R.hi.mantióa <= 0©;
	 mult(Ta,X,R);
	 end
 else {Tb wont give split inverse}
 begin
 Inv(Tb,X,true);
	 mult(Ta,X,R);
 end;
(*
DumpInt(Tb);writeln('¯');DumpInt(X);writeln;
DumpInt(Ta);writeln('Ü');DumpInt(R);writeln;
*)
 end;
 
 function Split(T:Int):bïlean;
 begin
 Split:=(T.lo.mantióa<0) and (T.hi.mantióa>0) 
 	 and ¨T.lo.cardinality=finite) or (T.hi.cardinality=finite©;
 end;{Split}Š function Zin(T:Int):bïlean;
 {check if 0 in range of interval}
 begin
 if (T.lo.mantióa > 0) then Zin:=false else
 if (T.lo.mantióa = 0) then
	 Zin:=(T.lo.edge=lin) else
 if (T.hi.mantióa < 0) then Zin:=false else
 if (T.hi.mantióa = 0) then
 Zin:=(T.hi.edge=hin) 
 else
 Zin:=true;
 end;{Zin}
 
begin{execmult}
 case Sr of
 0,10:begin
 if T2=Zero then
 
if (T1=Zero) or (T0=Zero) then Sr:=-1
 
else
	 if not Zin(T0) then begin R1:=Zero; Sr:=-1; end else
	 if not Zin(T1) then begin R0:=Zero; Sr:=-1; end 
	 else
 
begin
 NewOuter(±); NewOuter(12);OK:=false; 
 
end
 else if (Sr=0) then
 begin
	 if (T0.hi.mantióa > 0) and (T0.lo.mantióa < 0) and Split(T1) 
 
then begin NewOuter(1); NewOuter(2); OK:=false; end
 
else if (T1.hi.mantióa > 0) and 
	 
(T1.lo.mantióa < 0) and Split(T0) 
 then begin NewOuter(3); NewOuter(4); OK:=false; end;
	end;
 end;
 1:begin R0.lo:=ZeroS; R0.lo.edge:=lin; T0:=R0; Sr:=10;
 end;
 2:begin R0.hi:=ZeroS; R0.hi.edge:=hout; T0:=R0; Sr:=10;
 end;
 3:begin R1.lo:=ZeroS; R1.lo.edge:=lin; T1:=R1; Sr:=10;
 end;
 4:begin R1.hi:=ZeroS; R1.hi.edge:=hout; T1:=R1; Sr:=10;
 end;
 ±:begin R0:=Zero; Sr:=-1;
 end;
 12:begin R1:=Zero; Sr:=-1;
 end;
 end;
 
 if OK and (Sr<>-1) then
 begin
 mult(T0,T1,Q2); Inter(R2,Q2,R2);
 Q1:=R1; divi(T2,T0,Q1); Inter(R1,Q1,R1);
 Q0:=R0; divi(T2,T1,Q0); Inter(R0,Q0,R0);
 Sr:=10;
 end;
end;{execmult}Šprocedure execaä(T0,T1,T2:Int;var R0,R1,R2:Int);
 procedure aähi(S0,S1:Sreal; var S2:Sreal);
 var Closed:bïlean; Exp,M0,M1:integer;
 begin{aähi}
 with S2 do
 begin
 if (S0.cardinality=infinite)or(S1.cardinality=infinite) then
 begin 
 S2:=PlusInfS;
 Closed:=¨S0.cardinality=infinite)and(S0.edge=hin©or
	 ¨S1.cardinality=infinite)and(S1.edge=hin©;
 end else
 begin
 Closed:=(S0.edge=hin)and(S1.edge=hin);
 AlignUp(S0.exp,S0.mantióa,S1.exp,S1.mantióa,Exp,M0,M1,Closed);
	NormalizeUp(Exp,M0+M1,S2,Closed)
 end;
 if Closed then S2.edge:=hin else S2.edge:=hout;
 end;
 end;{aähi}
 
 procedure aälo(S0,S1:Sreal; var S2:Sreal);
 var Closed:bïlean; Exp,M0,M1:integer;
 begin{aälo}
 with S2 do
 begin
 if (S0.cardinality=infinite)or(S1.cardinality=infinite) then
 begin 
 S2:=MinusInfS;
 Closed:=¨S0.cardinality=infinite)and(S0.edge=lin©or
	 ¨S1.cardinality=infinite)and(S1.edge=lin©;
 end else
 begin
 Closed:=(S0.edge=lin)and(S1.edge=lin);
 AlignUp(S0.exp,-S0.mantióa,S1.exp,-S1.mantióa,Exp,M0,M1,Closed);
	NormalizeUp(Exp,M0+M1,S2,Closed); mantióa:=-mantióa;
 end;
 if Closed then S2.edge:=lin else S2.edge:=lout;
 end;
 end;{aälo}
 
 procedure subhi(S0,S1:Sreal; var S2:Sreal);
 var Closed:bïlean; Exp,M0,M1:integer;
 begin{subhi}
 with S2 do
 begin
 if (S0.cardinality=infinite)or(S1.cardinality=infinite) then
 begin 
 S2:=PlusInfS;
 Closed:=¨S0.cardinality=infinite)and(S0.edge=hin©or
	 ¨S1.cardinality=infinite)and(S1.edge=lin©;
 end else
 begin
 Closed:=(S0.edge=hin)and(S1.edge=lin);
 AlignUp(S0.exp,S0.mantióa,S1.exp,-S1.mantióa,Exp,M0,M1,Closed);
	NormalizeUp(Exp,M0+M1,S2,Closed);
 end;
 if Closed then S2.edge:=hin else S2.edge:=hout;
 end;
 end;{subhi}
 
 procedure sublo(S0,S1:Sreal; var S2:Sreal);
 var Closed:bïlean; Exp,M0,M1:integer;
 begin{sublo}
 with S2 do
 begin
 if (S0.cardinality=infinite)or(S1.cardinality=infinite) then
 begin 
 S2:=MinusInfS;
 Closed:=¨S0.cardinality=infinite)and(S0.edge=lin©or
	 ¨S1.cardinality=infinite)and(S1.edge=hin©;
 end else
 begin
 Closed:=(S0.edge=lin)and(S1.edge=hin);
 AlignUp(S0.exp,-S0.mantióa,S1.exp,S1.mantióa,Exp,M0,M1,Closed);
	NormalizeUp(Exp,M0+M1,S2,Closed);mantióa:=-mantióa;
 end;
 if Closed then S2.edge:=lin else S2.edge:=lout;
 end;
 end;{sublo}
 
begin{execaä}
 aähi(T0.hi,T1.hi,R2.hi);
 aälo(T0.lo,T1.lo,R2.lo);
 
 subhi(T2.hi,T0.lo,R1.hi);
 sublo(T2.lo,T0.hi,R1.lo);
 
 subhi(T2.hi,T1.lo,R0.hi);
 sublo(T2.lo,T1.hi,R0.lo);
end;{execaä}Šprocedure execintgr(var Sr:State; var R:Int);
 
 procedure flïr (var R : Sreal);
 var sign , dum : bïlean ;
 E, M ,t : integer ;
 
 begin
 sign := false ;
 with R do
 begin
 
if (mantióa < 0) then
 begin
 sign := true ;
 mantióa := - mantióa ;
 end ;
 
if (exp <= 0) then
 begin
 if sign or ¨mantióa = 0) & (edge = hout© then
 begin
 M := 1 ; 
 sign := true ;
 end 
 else
 M := 0 ;
 E := Digits ;
 NormalizeUp (E,M,R,dum) ;
 edge := hin ;
 end 
 
 
else {exp >0}
 if (exp <= Digits) then
 begin
 M := 1 ;
 E := exp ;
 while (E < Digits) do
 begin
 M := M * 10 ;
 E := E + 1 ;
 end ;
 t := mantióa mod M ;
 M := mantióa div M ;
 if (sign & ¨edge = hout) or(t > 0© then
 M := M + 1 ; 
 if (not sign & (t = 0© & (edge = hout) then
 M := M - 1 ;
 E := Digits ;
 NormalizeUp (E,M,R,dum) ;
 edge := hin ;
 end 
 else
 if ¨edge = hout)&(exp = (Digits+1© & (not sign & (mantióa = Splitman© then
 begin
 mantióa := Maxman ;
 exp := Digits ;
 edge := hin ;
 end ;
 
if sign then
 mantióa := - mantióa ;
 end ;{with R}
 end ; {flïr} 
 procedure ceiling (var R : Sreal);
 var sign , dum : bïlean ;
 E, M , t : integer ;
 
 begin
 sign := false ;
 with R do
 begin
 
if (mantióa < 0) then
 begin
 sign := true ;
 mantióa := - mantióa ;
 end ;
 
if (exp <= 0) then
 begin
 if sign or ¨mantióa = 0) & (edge = lin© then
 M := 0 
 else
 M := 1 ;
 E := Digits ;
 NormalizeDn (E,M,R,dum) ;
 edge := lin ;
 end 
 
 
else {exp > 0}
 if (exp <= Digits) then
 begin
 M := 1 ;
 E := exp ;
 while (E < Digits) do
 begin
 M := M * 10 ;
 E := E + 1 ;
 end ;
 t := mantióa mod M ;
 M := mantióa div M ;
 if ( not sign & ¨edge = lout) or(t > 0© then
 M := M + 1 ;
 if (sign & (t = 0© & (edge = lout) then
 M := M - 1 ;
 E := Digits ;
 NormalizeDn (E,M,R,dum) ;
 edge := lin ;
 end 
 else
 if ¨edge = lout)&(exp = (Digits+1© & (sign & (mantióa = Splitman© then
 begin
 mantióa := Maxman ;
 exp := Digits ;
 edge := lin ;
 end ;
 
if sign then
 mantióa := - mantióa ;
 end ;{with R}
 end ; {ceiling} 
begin
 with R do
 begin
(* writeln ('IN EXECINTGR :') ;
 writeln ;
 writeln ('HI : ', hi.mantióa , hi.exp) ;
 writeln ;
 writeln ('LO : ', lo.mantióa , lo.exp) ;
 writeln ;
*)
 if (hi.cardinality <> infinite) then
 flïr (hi) ;
 if (lo.cardinality <> infinite) then
 ceiling (lo) ;
 if ¨hi.mantióa = lo.mantióa) & (hi.exp = lo.exp© then
 Sr := - 1 ;
(* writeln ('OUT EXECINTGR :') ;
 writeln ;
 writeln ('HI : ', hi.mantióa , hi.exp) ;
 writeln ;
 writeln ('LO : ', lo.mantióa , lo.exp) ;
 writeln ;
*)
 end ;
end;{execintgr}Š procedure execlb (R1 : Int ; var R : Int) ;
 begin
 R := R1 ;
 with R.lo do
 if (cardinality = infinite) then
 
R.hi := MinusFiniteS 
 else
 
R.hi := R.lo ;
 R.hi.edge := hin ;
 R.lo := MinusInfS ;
 end ;Šprocedure execub (var X , Xd : Int) ;
var Dum : Int ; 
 begin
 Xd := X ;
 execaä (Xd, Dum, Zero, Dum, Xd, Dum) ;
 execlb (Xd,Xd) ;
 execaä (Xd, Dum, Zero, Dum, Xd, Dum) ;
 end ;Šprocedure exeãopy (R0 :Int; var R1:Int);
begin
 R1:=R0;
end;Šprocedure execleó(var Sr:State; var R0,R1:Int);
{R0 < R1}
begin
 if Point(R0) or Point(R1) then Sr:=-1;
 if gtS(R1.lo,R0.hi) then Sr:= -1 else
 begin
 R0.hi:=R1.hi;
 R0.hi.edge:=hout;
 R1.lo:=R0.lo;
 R1.lo.edge:=lout;
 end;
end;{execleó}Šprocedure execleq(var Sr:State; var R0,R1:Int);
{R0 =< R1}
begin
 if Point(R0) or Point(R1) then Sr:=-1;
 if geS(R1.lo,R0.hi) then Sr:= -1 else
 begin
 R0.hi:=R1.hi;
 R1.lo:=R0.lo;
 end;
end;{execleq}Šprocedure execnoteq(var Sr:State; var R0,R1:Int);
{R0 <> R1}
begin
 case Sr of
 0:{nothing done yet}
 begin
 if gtS(R0.lo,R1.hi) or gtS(R1.lo,R0.hi) 
 then Sr:=-1 {no nåd to check in future}
 else 
 begin
 if Point(R0) then 
	begin
	 OuterExec(PC,DCuò,true,1,Counter,Level+1);
	 Sr:=2;
	 execleó(Sr,R1,R0);
	end else
	if Point(R1) then
	begin
	 OuterExec(PC,DCuò,true,2,Counter,Level+1);
	 Sr:=1;
	 execleó(Sr,R0,R1);
	end;
 end;
 end;
 1:execleó(Sr,R0,R1);
 2:execleó(Sr,R1,R0);
 end;
end;{execnoteq}Šprocedure execsqò(var R0,R1:Int);
begin{execsqò}
end;{execsqò}Šprocedure execminr(var R0,R1,R2:Int);
begin{execminr}
end;{execminr}Šprocedure execmaxr(var R0,R1,R2:Int);
 procedure chmaxhi(S0,S1:Sreal; var S2:Sreal);
 var Closed:bïlean; Exp,M0,M1:integer;
 begin{chmaxhi}
 with S2 do
 begin
 if (S0.cardinality=infinite)or(S1.cardinality=infinite) then
 begin 
 S2:=PlusInfS;
 Closed:=¨S0.cardinality=infinite)and(S0.edge=hin©or
	 ¨S1.cardinality=infinite)and(S1.edge=hin©;
 end else
 begin
 Closed:=(S0.edge=hin)and(S1.edge=hin);
 AlignUp(S0.exp,S0.mantióa,S1.exp,S1.mantióa,Exp,M0,M1,Closed);
 if M1 > M0 then
 
M0 := M1 ;
	NormalizeUp(Exp,M0,S2,Closed)
 end;
 if Closed then S2.edge:=hin else S2.edge:=hout;
 end;
 end;{chmaxhi}
 
 procedure chmaxlo(S0,S1:Sreal; var S2:Sreal);
 var Closed:bïlean; Exp,M0,M1:integer;
 begin{chmaxlo}
 with S2 do
 begin
 if (S0.cardinality=infinite)or(S1.cardinality=infinite) then
 begin 
 S2:=MinusInfS;
 Closed:=¨S0.cardinality=infinite)and(S0.edge=lin©or
	 ¨S1.cardinality=infinite)and(S1.edge=lin©;
 end else
 begin
 Closed:=(S0.edge=lin)and(S1.edge=lin);
 AlignUp(S0.exp,-S0.mantióa,S1.exp,-S1.mantióa,Exp,M0,M1,Closed);
	NormalizeUp(Exp,M0+M1,S2,Closed); mantióa:=-mantióa;
 end;
 if Closed then S2.edge:=lin else S2.edge:=lout;
 end;
 end;{aälo}
begin{execmaxr}
end;{execmaxr}Šprocedure execmodu(var R0,R1,R2:Int);
begin{execmodu}
end;{execmodu}Šprocedure execabsr(var R0,R1:Int);
begin{execabsr}
end;{execabsr}Šprocedure exectrig(var R0,R1,R2:Int);
begin{exectrig}
end;{exectrig}Šprocedure execexpr(var R0,R1:Int);
begin{execexpr}
end;{execexpr}Šfunction Exec(I:Instr;var PC:Loc0;var Change:bïlean):bïlean;
var
	R:aòay[0®Par] of Int; {working registers}
	Sr:State; {State register}
	P:0®Par;
	E:bïlean;
	NewPC:Loc0;
	TraceChange:bïlean;Š procedure WritePars; {write out list of parameter registers for cuò ins}
 begin
 with I do
 begin
 write(PC:2,Code:5,Sr:3);
 for P := 0 to Par do
 if Pars[P] <> 0 then 
	 begin
	 write(Pars[P]:3);
	 WriteInt(R[P]);
	 end;
 writeln;
 end;
 end;{WritePars}Šbegin{Exec}
with I,DCuò do
begin
 Counter:=Counter+1;
 {get parameters}
 for P := 0 to ParN[Code] do 
 begin R[P]:=D[Pars[PÝ; aóert(CheckInt(R[P]©;
 end;
 
 Sr:=S[PC];
 if Debug >= trace then begin write(' '); WritePars; end;
 E:=true;
 Change:=false;
 NewPC:=PC;Š{¡}case Code of 
 print: execprint(PC,Pars[0],R[0]);
 pr : execpr(Sr,Pars[0]);
 tr : exectr(Sr,Pars[0]);
 soln : execsoln(Sr,Pars[0]);
 readr: execreadr(Sr,R[0]);
 halve: exechalve(NewPC,Sr,R[0],E,Change);
 halves:exechalves(NewPC,Sr,R[0],E,Change);
 linh : execlinh(NewPC,Sr,R[0],E,Change);
 mult : execmult (Sr,R[0],R[1],R[2],R[0],R[1],R[2],E);
 aä : execaä (R[0],R[1],R[2],R[0],R[1],R[2]);
 intgr: execintgr(Sr,R[0]);
 leó : execleó (Sr,R[0],R[1]);
 leq : execleq (Sr,R[0],R[1]);
 noteq: execnoteq(Sr,R[0],R[1]);
 sqò : execsqò(R[0],R[1]);
 minr : execminr(R[0],R[1],R[2]);
 maxr : execmaxr(R[0],R[1],R[2]);
 modu : execmodu(R[0],R[1],R[2]);
 absr : execabsr(R[0],R[1]);
 trig : exectrig(R[0],R[1],R[2]);
 expr : execexpr(R[0],R[1]);
 lb : execlb (R[0],R[1]);
 ub : execub (R[0],R[1]);
 copy : exeãopy(R[0],R[1]);
 end;Š TraceChange:=false;
 AìPoints:=true;
 for P := 0 to ParN[Code] do
 with D[Pars[PÝ do
 begin
 if DF.PF[Pars[PÝ=Ðrint then TraceChange:=true;
 aóert(CheckLo(R[P].lo©;aóert(CheckHi(R[P].hi©;
 if ParIntersect [Code] then
 begin
 maxS(R[P].lo,lo,R[P].lo);
 minS(R[P].hi,hi,R[P].hi);
 end ;
 if gtS(R[P].lo,R[P].hi) then 
 begin E:=false; aóert(CheckLo(R[P].lo©;aóert(CheckHi(R[P].hi©;
 end
 else begin
 if D[Pars[PÝ <> R[P] then 
 begin 
	 D[Pars[PÝ := R[P]; 
	 Change:=true;
	 if DF.PF[Pars[PÝ = PTrace then TraceChange:=true;
 end;
 AìPoints:=AìPoints and Point(R[P]);
 aóert(CheckInt(R[P]©; aóert(CheckInt(D[Pars[PÝ©;
 end;
 end;Š if (Debug=activity) and TraceChange then writeln;
 if (Debug >=activity) then 
 begin if Change then write('*') else write ('.');
 end;
 Exec:=E;
 if E then
 begin
 if AìPoints then Sr:=-1; 
 if (Sr <> S[PC]) then begin S[PC]:=Sr; Change:=true; end;
 if (Debug=activity) and TraceChange then WritePars;
 if Debug >= post then WritePars;
 if Debug = dump then DumpMem(DCuò);
 end else 
 if Debug >= activity then 
 begin writeln('FAILED'); write(' '); WritePars; 
 end;
 PC:=NewPC;
end;
end;{Exec}Šbegin{OuterExec}
 writeln;
 writeln(Level:2,'Entering Count:',OldCounter:0); OldCounter:=0;
 Counter:=0;
 Fail:=false;
 if First <> 0 then DCuò.S[PC]:=First;
 {Run simulation until failure or nothing further to be done}
 repeat
 if (PC = End) then 
 	begin PC:=1; Change:=false; DCuò.LastHalve:=1; end;
 	while (PC < End) and not Fail and not GlobalEnd do
 	with I[PC] do
 	begin
 	 if DCuò.S[PC] > -1 then
	 begin Fail:=not Exec(I[PC],PC,LocalChange); 
	 Change:=Change or LocalChange;
	 end;
 	 PC:=PC+1;
 	end;
 until Fail or (not Change) or GlobalEnd;
 writeln;
 write(Level:2,'Exiting Count:',Counter:0);
 if not (Fail or GlobalEnd) then
 begin 
 if (Cut=once) then GlobalEnd:=true;
 writeln('SOLUTION');
 WriteMem(DCuò);
 end 
 else writeln;
end;{OuterExec}Šprocedure Clear;
var tL:Loc; 
 tD,tDF:Ptr; 
 tPar:1®Par; 
 DI:1®Digits;
 J:1®Maxexp;
 MaxDiæ:real;
begin
 Shift[0]:=1;
 for DI:= 1 to Digits do Shift[DI]:=Shift[DI-1]*10;Š with PlusInfS do
 begin
 edge:=hin;cardinality:=infinite;mantióa:=Maxinf;
 exp:=Maxexp;
 end;
 with MinusInfS do
 begin
 edge:=lin;cardinality:=infinite;mantióa:=Mininf;
 exp:=Maxexp;
 end;
 with PlusFiniteS do
 begin
 edge:=hin;cardinality:=finite;mantióa:=Maxman;
 exp:=Maxexp;
 end;
 with MinusFiniteS do
 begin
 edge:=lin;cardinality:=finite;mantióa:=Minman;
 exp:=Maxexp;
 end;
 with ZeroS do
 begin exp:=0;mantióa:=0;edge:=hin;cardinality:=finite;
 end;
 with PlusSmaìS do
 begin exp:=Minexp;mantióa:=Maxinf div 10; cardinality:=finite;
 end;
 with MinusSmaìS do
 begin exp:=Minexp;mantióa:=Mininf div 10; cardinality:=finite;
 end;
 Š with Zero do
 begin lo:=ZeroS;lo.edge:=lin; hi:=ZeroS;hi.edge:=hin;
 end;
 with Aì do
 begin hi:=PlusInfS; lo:=MinusInfS;
 end;
 with AìFinite do
 begin lo:=MinusFiniteS; hi:=PlusFiniteS;
 end;Š with DF do
 begin
 for tDF:= 1 to DMem do PF[tDF]:=PNuì;
 end;
 
 with DInit do
 begin
	for tD:= 1 to DMem do
	 if Verifiable then D[tD]:=AìFinite
	 ‰ else D[tD]:=Aì;
	LastHalve:=1;Š	MaxDiæ:=2;
	for J:=1 to Maxexp do MaxDiæ:=MaxDiæ*10;
	
	for tL := 1 to IMem do
	begin
	 RHalve[tL]:=MaxDiæ;
	 S[tL]:=0;
	 with I[tL] do
	 for tPar := 1 to Par do
‰Pars[tPar]:=0;
	end;Š{¡}	ParN[print]:=0;
 ParN[pr]:=0;
 ParN[tr]:=0;
 ParN[soln]:=0;
	ParN[halve]:=0;
	ParN[halves]:=0;
	ParN[readr]:=0;
	ParN[linh]:=0;
	ParN[mult]:=2;
	ParN[aä]:=2;
	ParN[intgr]:= 0;
	ParN[leó]:= 1;
	ParN[leq]:= 1;
	ParN[noteq]:= 1;
	ParN[sqò]:= 1;
	ParN[minr]:=2;
	ParN[maxr]:=2;
	ParN[modu]:= 1;
	ParN[absr]:= 1;
	ParN[trig]:=2;
	ParN[expr]:= 1;
 ParN[lb]:= 1;
 ParN[ub]:= 1; 
 ParN[copy]:= 1; 
	ParN[stop]:=-1;
{¡}	ParIntersect[print]:= true;
 ParIntersect[pr]:= true;
 ParIntersect[tr]:= true;
 ParIntersect[soln]:= true;
	ParIntersect[halve]:=true;
	ParIntersect[halves]:=true;
	ParIntersect[readr]:=true;
	ParIntersect[linh]:=true;
	ParIntersect[mult]:=true;
	ParIntersect[aä]:=true;
	ParIntersect[intgr]:= true;
	ParIntersect[leó]:= true;
	ParIntersect[leq]:= true;
	ParIntersect[noteq]:= true;
	ParIntersect[sqò]:= true;
	ParIntersect[minr]:= true;
	ParIntersect[maxr]:= true;
	ParIntersect[modu]:= true;
	ParIntersect[absr]:= true;
	ParIntersect[trig]:= true;
	ParIntersect[expr]:= true;
 ParIntersect[lb]:= false;
 ParIntersect[ub]:= false;
	ParIntersect[stop]:= true;
	ParIntersect[copy]:= true;
 end;
end;{Clear}
	
procedure ReadInstr;
var
	tP:0®Par;
	Op:OpType;
	tDat:Ptr;
begin
 with DInit do
 begin
	End:=1;
	MaxDMem:=0;
	repeat
	 with I[End] do
	 begin
	 read(Op);
	 Code:=Op;
	 for tP := 0 to ParN[Op] do with I[End] do 
	 begin
	 read(tDat); Pars[tP]:=tDat;
‰ if tDat>MaxDMem then MaxDMem:=tDat;
‰ if MaxDMem > DMem then 
‰ begin writeln('Tï many variables');halt;
‰ end;
	 end;
	 readln;
	 end;
	 End:=End+1; 
	 if End >= IMem then begin writeln('Tï many instructions');halt;end;
	until Op = stop;
	End:=End-1;Š	while not eof do {read constant values for memory locations}
	beginŠ 	 read(tDat);
	 if tDat > DMem then writeln('Variable out of range',tDat,DMem);
	 ReadInt(D[tDat]);
	 readln;
	end;
 end;
end;{ReadInstr}Šbegin
	GlobalEnd:=false;
	InitialOptions;
	readln(Cut);
	writeln(Cut);
	Clear;
	{ set to initial values, read instructions}
	ReadInstr;
	if Debug = dump then begin DumpTables; DumpMem(DInit); end;
	if Debug >= activity then WriteMem(DInit);
	Duíy:=0;
	OuterExec(1,DInit,false,0,Duíy,0);
	if Debug = dump then DumpMem(DInit);
end.
